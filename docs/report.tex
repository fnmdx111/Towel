
\documentclass{report}

\usepackage[left=1in, right=1in, top=1in, bottom=1in]{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{mdframed}
\usepackage{showexpl}
\usepackage[normalem]{ulem}
\usepackage{minted}

\usepackage[usenames, dvipsnames]{pstricks}
\usepackage{epsfig}

\title{The Towel Report}
\author{Zihang Chen (zc2324) Baochan Zheng (bz2269) Guanlin Chen (gc2666)}

\makeatletter\@addtoreset{chapter}{part}\makeatother%

\mdfdefinestyle{detail}{%
rightline=true,innerleftmargin=10,innerrightmargin=10,
frametitle={Implementation Detail},
frametitlerule=true,frametitlerulecolor=white,
frametitlebackgroundcolor=cyan,
frametitlerulewidth=2pt}

\mdfdefinestyle{hint}{%
rightline=true,innerleftmargin=10,innerrightmargin=10,
frametitle={Hint},
frametitlerule=true,frametitlerulecolor=white,
frametitlebackgroundcolor=yellow,
frametitlerulewidth=2pt}

\mdfdefinestyle{example}{%
rightline=true,innerleftmargin=10,innerrightmargin=10,
frametitle={Example},
frametitlerule=true,frametitlerulecolor=white,
frametitlebackgroundcolor=green,
frametitlerulewidth=2pt}

\mdfdefinestyle{example}{%
rightline=true,innerleftmargin=10,innerrightmargin=10,
frametitle={Example},
frametitlerule=true,frametitlerulecolor=white,
frametitlebackgroundcolor=green,
frametitlerulewidth=2pt}

\mdfdefinestyle{warning}{%
rightline=true,innerleftmargin=10,innerrightmargin=10,
frametitle={Be warned!!},
frametitlerule=true,frametitlerulecolor=white,
frametitlebackgroundcolor=red,
frametitlerulewidth=2pt}

\newcommand{\mstd}[1]{\texttt{#1\textbackslash Std}}
\newcommand{\mtilde}[1]{\textasciitilde}

\newcommand{\marg}[1]{\texttt{\mtilde ~#1}}
\newcommand{\mla}[0]{~$\leftarrow$ ~}
\newcommand{\arithstd}[1]{\marg{1} \mla \marg{2} \mla \mstd{#1}}

\newcommand{\inst}[1] {\texttt{inst:#1}}


\begin{document}
\maketitle

\vspace{10cm}
\begin{figure}
\centerline{\includegraphics[scale=0.75]{images.jpg}}
\end{figure}
\newpage

\tableofcontents

\chapter{Language Overview}\label{chap:overview}

Towel is a stack-based, general-purpose, postfix-syntaxed, dynamically strong-typed, functional, language targeted at the Towel Virtual Machine.

\section[Stack-based]{Stack-based\footnote{It's not only stack-based, it's actually stack-stack-based. See also \autoref{sec:basics}.}}

Although stack-based programs are hard to reason about, it's really efficient and powerful to use once you get the gist of it. It is comes with natural support for imperative programming paradigm. It also enforces programmer's to think about the evaluation order of their potentially side-effected code.

\section{General-purpose}

Towel is designed with the universe in mind. So the syntax of it is expressive and reasonable with as few limitations as possible, yet easy to understand.

\section{Postfix-syntaxed}

The relationship between postfix syntax and stacks is just like a towel to a hitchhiker, so why not?

\section{Dynamically Strong-typed}

This means that Towel maintains types at runtime with no implicit type castings whatsoever, the compiler does not do type checking. However, it does scope analysis for every piece of Towel code.

\section{Functional}

Once you have full-fledged functional framework, you have the whole world. For example, Church booleans, Church numbers, etc. Or more realistic, you can use functions to emulate records, or even object-oriented programming!

\section{Towel Virtual Machine}

Why a virtual machine? Because we think this is the most portable and easy way to do a prototype for a new language. After you got the language working, you can do all kinds of crazing things, like compiling the bytecode that the VM reads into a native application.

\part{The Towel Reference Manual}

\chapter{Lexical Elements}\label{chap:grammar}
\section{Keywords}

Keywords in the Towel programming language is as follows:
\begin{verbatim}
if>=0 if>0 if<=0 if<0 if~0 if=0 ift iff ife ifne
match fun bind type also then export import ,\
\end{verbatim}

\section{Punctuations}

Punctuations used in the Towel programming language are as follows:

\begin{itemize}
\item Whitespace characters are simply ignored.
\item These characters have special meanings in the Towel programming language: \texttt{` ' `` , ; ( ) [ ] { } \char`\\ ~  @ EOF}. This means that you cannot use these characters in names and atoms. \footnote{In other words, you can use any other punctuation characters in names and atoms.}
\item Any unprintable character is reserved and won't be used.
\end{itemize}

\section{Names}

Names are used for naming (or to be more precise, referencing to) values. Valid names should not start with reserved punctuations, lowercased letters, and numbers.

More formally,
\begin{verbatim}
  unprintables ::= [all the unprintable ASCII characters]
  whitespaces ::= ['\n' '\t' ' ' '\r']
  reserved_punct ::= ['`' ''' '"' ',' ';' '\' '@' 
                      '(' ')' '[' ']' '{' '}' whitespaces unprintables]
  valid_punct ::= ['!' '~' '#' '$' '%' '^' '&' '*' '-' '_' '+' '=' '|'
                   ':' '<' '>' '?' '/']
  BQUOTE ::= '`'
  SQUOTE ::= '''
  DQUOTE ::= '"'
  COMMA ::= ','
  SEMICOLON ::= ';'
  PERIOD ::= '.'
  SLASH ::= '\'
  AT ::= '@'
  LPAREN ::= '('
  RPAREN ::= ')'
  LBRACKET ::= '['
  RBRACKET ::= ']'
  LBRACE ::= '{'
  RBRACE ::= '}'

  digit ::= ['0'-'9']
  hexdigit ::= ['0'-'9' 'a'-'f' 'A'-'F']
  bindigit ::= ['0'-'1']
  lc_chars ::= ['a'-'z']
  NAME ::= [^ '-' reserved_punct digit lc_chars] [^ reserved_punct]*
\end{verbatim}

You can also resolve names in other namespaces (what we call \textit{modules} in Towel) by concatenating them with a backslash.

\begin{mdframed}[style=example]
If you would like to access the name \texttt{+} in module \texttt{Std}, which is in module \texttt{MyStdlib}, you can write:

\begin{verbatim}
+\Std\MyStdlib
\end{verbatim}

\end{mdframed}

\section{Literals}

Most easy-to-use languages support a wide variety of literals (Python is a good example and Java is not). The Towel programming language supports literals for atoms, integers (fixed, unsigned fixed, big), floats, strings, lists and tuples. They are defined as follows (rule for list literals will be revealed later):
\begin{verbatim}
  ATOM ::= lc_chars [^ reserved_punct]*

  signed ::= ['+' '-']
  fint_body ::= (("0d"? digit+) | ("0x" hexdigit+) | ("0b" bindigit+))
  FINT ::= signed? fint_body
  INT ::= signed? digit+ ['L' 'l']
  UFINT ::= '+'? fint_body ['U' 'u']

  dot ::= '.'
  int ::= digit+
  frac ::= digit+
  exp = 'e' signed? int
  dot_float = ((dot frac) | (int dot frac)) exp?
  exp_float = int (dot frac)? exp
  FLOAT ::= signed? (dot_float | exp_float)

  string_char ::= [^ '\' ''']
  string_esc_seq ::= '\' string_char
  string_item ::= string_char | string_esc_seq
  STRING ::= ''' string_item* '''
  (Rules for strings is from the lexical parsing section of the Python
   language reference manual.)
\end{verbatim}

\begin{mdframed}[style=detail]
Because positive (or negative) numbers, ``+1.'' for example, also uses the plus punctuation, \texttt{NAME} is actually more complicated than what's written above:
\begin{verbatim}
  NAME ::= valid_upper_char common_valid_char*
         | '+' common_valid_char_no_digits?
         | '+' common_valid_char_no_digits common_valid_char*
         | '-' common_valid_char_no_digits?
         | '-' common_valid_char_no_digits common_valid_char*
\end{verbatim}
\end{mdframed}

\section{Comments}

Comments are defined as follows:
\begin{verbatim}
  __COMMENTS ::= '"' [^ '"']* '"'
\end{verbatim}

\section{Lexical Error}

When the scanner encounters any other character not mentioned above, it will raise a \texttt{LexicalError} exception.

\chapter{Data Types}
\label{chap:data-types}

This chapter covers the basics on types in Towel. It worth mentioning here that all the values of whatever types of Towel is immutable.

\section{Built-in Types}

Towel provides to the user the following primitive built-in types:
\begin{itemize}
\item Atom
\item Fixed integer or, FixedInt
\item Unsigned fixed integer or, UFixedInt
\item Big integer or, Int
\item String
\item Float
\item List
\item Tuple
\end{itemize}

\subsection{Functions}

Functions are one of the most important kind of values in Towel. They can be returned as values, passed as arguments, and evaluated as regular functions. This kind of feature is often called as \textit{functions as first-class citizens}. A function gets its argument from caller's data stack (often the data stack beneath it, or the same stack if it's a tail recursive call), and returns the TOS on its data stack.

\begin{mdframed}[style=hint]
Although it is not recommended, you can always use the \mstd{!!pack} routine\footnote{A routine in Towel is a function with side-effects (or stack-effects).} to pack multiple values in the callee and \mstd{!!unpack} them in the caller to achieve multiple return values.
\end{mdframed}

\subsection{Atoms}

Atoms are special names uniquely bound to integer constants. But they are not comparable to integers, nor can they be applied to numeric operations. It's also meaningless to compare between two atoms.

Towel predefines \texttt{false} and \texttt{true} as boolean atoms.

\begin{mdframed}[style=detail]
Although they are not comparable to integers, they can be tested against each other to see if they are the same. The earlier the atom appears in code, the smaller the integer constants it gets.
\end{mdframed}

\subsection{\texttt{(U)FixedInt}s, \texttt{Int}s, \texttt{Float}s}

(Unsigned) fixed integers and floats are 64bit integers and floats. \texttt{Int}s are signed integers of arbitrary precision (like those \texttt{int}s in Python). These types are said to be subclass of the class \texttt{Number} (only conceptually), which is to say all these types are supported by basic arithmetic operations. However, bitwise operations will only take (\texttt{U})\texttt{FixedInt}s as arguments.

\subsection{Strings}

A string is an immutable data structure of fixed-length sequence of characters (or bytes).

\begin{mdframed}[style=detail]
  To see how long a string can be in the underlying OCaml environment, go to your OCaml toplevel and type \texttt{Sys.max\_string\_length;;}.
\end{mdframed}

\subsection{Lists and Tuples}

Lists and tuples are enumerable types in Towel.

Lists are accepted by list-related functions, such as \mstd{\#hd}, \mstd{\#tl}, \mstd{?\#} (list emptiness test). However, note that only lists are supported by the \mstd{\#cons} operation. When you \mstd{\#cons} to a tuple, Towel Virtual Machine will blow up.

Tuples are accepted by \mstd{\#tn} to access specific element of them. They can also be tested emptiness with \mstd{?\#}.

\section{Conversion between Types}

Most of the operations can only deal with homogeneous data types. For example, addition can only happen between two fixed integers, or two unsigned fixed integers, or big integers, etc. A addition between a float and an integer will result in error.

If you really would like to add a float to an integer, either use the built-in function \mstd{\mtilde ~float} to convert the integer into a float, or use \mstd{\mtilde  ~int} to convert the float into an integer.

\section{Runtime Type Reflection}

You can use the built-in function \mstd{\string^?} to get the type of TOS. The returned type is a built-in value that represents types. Type values can be test against each other for equality with \mstd{\string=}.

\chapter{Hello, Word}
\label{chap:forms}

\section{Program Structure}\label{sec:basics}

A Towel program consists of one or multiple so-called \textbf{words} or \textbf{forms}.

When encountered multiple words, they are always evaluated one by one in the order they appear. Although most of the times, Towel remains in a postfix fashion, but for the sake of convenience, some parts of the grammar is of prefix or infix style (e.g. the bind form and namespaced name invocation).

A word, can be one of the following:
\begin{itemize}
\item literal
\item name
\item sequence
\item backquote
\item \texttt{if} forms
\item function form
\item bind form
\item import and export form
\end{itemize}

You should also know that the computational model Towel uses is based on stacks, or to put it more precisely, stack of stacks. That is to say, when you invoke a function, a new stack in created for that particular function, and after it returns the new stack gets destroyed. This avoids potential corruption of only a single stack.

\section{Rules for Evaluation}

When you reference to a word, Towel does the following:
\begin{itemize}
\item For literals, it pushes back them directly;
\item For a backqoute, it pushes back whatever is quoted (i.e. without evaluating);
\item For a function, it creates a new stack, gets whatever required arguments to it from caller's stack, does the computation, pushes back the TOS of its own stack to caller's stack (this is called in Towel ``returning a value'');
\item For a sequence, it creates a new function out of the body of the sequence and evaluates that function;
\item For a name, it looks up the value it references to, evaluates that value and pushes back the evaluated value.
\item For \texttt{if} forms, test against the TOS and evaluate the word in respective branch;
\item For bind-then form, it pushes a new scope, evaluates the values on stack that get bound (both \texttt{bind} clause and \texttt{also} clause) and binds the values evaluated to the names, then it evaluates the \texttt{then} clause within current scope. Finally it pops the scope.
\end{itemize}

\section{Rules for Scoping}

Only two forms in Towel can create a new scope: the function form and the \texttt{bind-then} form. This means that a scope is created when entering a function, or a \texttt{bind-then} form, and implies that a scope is destroyed when exiting a function, or a \texttt{bind-then} form.

A name is only referenceable within the scope it is bound, plus the child scopes of that scope. For closures, the captured names are poured into the function's scope by default.

\section{Literals}

A literal is a literal value whose type is of the data types we have talked about in \autoref{chap:data-types}.

\subsection{Atoms}

You can create atoms by writing any lowercased letter followed by arbitrary length of characters that are not reserved punctuations and keywords.

Atoms are unique across the entire program. Because atoms are assigned with a unique unsigned 64-bit integer, so you can have no more than $2^{64}$ of them in your program.

\begin{mdframed}[style=detail]
  Boolean type is implemented as atoms. \mstd{:and}, \mstd{:or}, \mstd{:not} work for integers as well as booleans.
\end{mdframed}

\subsection{Numbers and Strings}

You can create number and string literals by writing like this:
\begin{mdframed}[style=example]
\begin{verbatim}
  1 -1 2 -3 5 -8 13 -21
  +4242424242424242424242424242424242424242424242424242424242L
  -3141592653589793238462643383279l
  3U +0x4579u 0b11101 0d1234
  1.1e1 -0.1 'don\'t panic'
\end{verbatim}
\end{mdframed}

Note that string items are surrounded by single quote, rather than double quote.\footnote{Because you don't have to hit the \textit{shift} key when inputing single quotes. Same goes for brackets.}

\subsection{Lists}

When creating a list literal, you must write a list of words separated with spaces in a pair of brackets, like the following code:
\begin{mdframed}[style=example]
\begin{verbatim}
  [arthur-dent ford-prefect betelgeuse]
  [Spam Spam Spam]
  [Spam ifne (More Spam)`, (Less Spam)`] (valid but bad example)
\end{verbatim}
\end{mdframed}

\begin{mdframed}[style=warning]

Although you can safely write list literals with names, and literals (integers, atoms, or even list), but because of Towel's stack-based nature, complicated words in a list literal may not turn out to be what you want.

When the Towel compiler compiles a list literal into instructions, it first generates a pair of instructions called \texttt{push-lnil}, \texttt{end-list}. Then it compiles the words being the content of the list literal, and put the generated code between that pair of instructions. But be warned that, when entering the \texttt{push-lnil} and \texttt{end-list} pair, the target of most of the pushing actions will be come the newly pushed list, rather than the data stack. For example,

\begin{verbatim}
  push-lnil
  push-lit 1u
  push-lit 2a
  push-lit 3l
  end-list
\end{verbatim}

will result in \texttt{[1 2 3]}. And

\begin{verbatim}
  push-lnil
  push-lit 1u
  push-lnil
  push-lit 2a
  push-lnil
  push-lit 3l
  end-list
  end-list
  end-list
\end{verbatim}

will result in \texttt{[1 [2 [3]]]}. Just like what we expected, right?

But consider the following,

\begin{verbatim}
  (2 3 [1 2 +] !println)
\end{verbatim}

This is syntactically correct Towel, but the problem is that it tries to evaluate a function within the environment of creating a list. The user might expect the output being \texttt{[3]} but that not the case: before the name \texttt{+}, the stack is like the following,

\begin{verbatim}
  {| 2 3 [1 2 |}
\end{verbatim}

when the addition function tries to grab its arguments, it first pop the unfinished \texttt{[1 2} as its argument, which is incorrect already. And it then gets its second argument from the stack, which is obviously 3.

You should also be very cautious with

\begin{verbatim}
  (1 2 [3 if>0 +`, -`])
\end{verbatim}

This \texttt{if>0} is tested against the TOS, which is the unfinished list \texttt{[3}!

So in general, never ever put complicated words in a list literal. If you are really forced to do so, enclose the word in a sequence (parentheses).
\end{mdframed}

\subsection{Tuples}

Tuples are fixed length lists, this means that you cannot CDR from them, nor CONSing to them. Create tuples like this:
\begin{mdframed}[style=example]
\begin{verbatim}
  [\ arthur-dent ford-prefect betelgeuse]
  [\] "an empty tuple"
\end{verbatim}
\end{mdframed}
\section{Sequence}

Sequences are short-hand forms for creating anonymous functions with no arguments. You can create a sequence by writing the sequence body between a pair of parentheses.

Towel also provides another kind of sequences, the shared sequences. This kind of sequences share the same context (such as stack and scope) with the caller. When creating such sequences, you add an at symbol right after the left parenthesis.

\begin{mdframed}[style=example]
\begin{verbatim}
  ((A B - if>0 1, 0) (A B + if<0 2, 3) :and) "non-shared regular sequences"
  (A B - (@ if>0, 1, 0) !println) "prints 1 or 0"
\end{verbatim}
\end{mdframed}

You may want to create a shared sequence when defining tail-recursive functions, otherwise, you lose the advantage of not stacking up contexts.

\begin{mdframed}[style=hint]
Just for your information, the Towel compiler automatically strips off the creation of certain unnecessary sequences for performance reasons. For example, the following sequences will be optimized out.

\begin{verbatim}
  bind THE-ANSWER 42
  then (THE-ANSWER !println)

  42 if>0 ('The answer is greater than void.' !println),
    ('The answer is less than void.' !println)
\end{verbatim}

The appearances of the sequences above are simply only of syntactical reasons, namely, to avoid ambiguity of the grammar. They can be safely removed semantically.

See \autoref{sec:switches} for more details.
\end{mdframed}

\section{Backquote}

Towel evaluates and pushes everything it encounters, you can use backquotes the values to prevent Towel from evaluating them so that Towel pushes them directly onto the data stack. Backquotes are created by appending a backquote to the words you want to backquote.

You can backquote only limit types of words:
\begin{itemize}
\item literals; Towel pushes the literal back immediately
\item names; Towel pushes whatever the name references to onto the stack, without evaluating them
\item sequences and functions; Towel pushes them onto the stack without executing it
\item backquotes; why would you do such a thing?
\end{itemize}

\begin{mdframed}[style=hint]
  You can create backquoted shared sequence by replacing the
  parentheses with braces and dropping both the at symbol and
  backquote. See also \autoref{ssec:backquote} and
  \autoref{ssec:macro}.
\end{mdframed}
\section{\texttt{if} Forms}

Towel supports 10 kinds of \texttt{if} forms for the sake of readability and convenience. They are of the same form, while differing in the predicate they use.

An \texttt{if} form contains two words separated by a comma. When evaluating an \texttt{if} form, Towel tests the TOS and see if it satisfies the condition. If the condition is satisfied, the first word (called the true branch) is evaluated and the second word is ignored\footnote{This is basically why you want a designated condition form}, and vice versa. By default, \texttt{if} forms does not consume TOS, see \autoref{sec:switches} for more detail.

The predicates used by \texttt{if} forms are as follows:
\begin{itemize}
\item \texttt{if>0}, if TOS is a number and greater than 0
\item \texttt{if>=0}, if TOS is a number and greater than or equal to 0
\item \texttt{if<0}, if TOS is a number and less than 0
\item \texttt{if<=0}, if TOS is a number and less than or equal to 0
\item \texttt{if=0}, if TOS is a number and equal to 0
\item \texttt{if\textasciitilde 0}, if TOS is a number and not equal to 0
\item \texttt{ife}, if the stack is empty
\item \texttt{ifne}, if the stack is not empty
\item \texttt{ift}, if TOS is an atom and equal to \texttt{true}
\item \texttt{iff}, if TOS is an atom and equal to \texttt{false}
\end{itemize}

See \autoref{chap:examples} for examples on \texttt{if} forms.

\section{Function Form}

Function forms are used to define anonymous functions of arbitrary arity. To define a function, first type the keyword \texttt{fun}, and a list of argument declarations and finally a word for the body of the function.

Because function form creates and evaluates function in place, the following code is valid\footnote{But not semantically correct, because you cannot invoke a number as function.}:
\begin{mdframed}[style=example]
\begin{verbatim}
  fun A B,
    (A B fun X, (3 X +))
\end{verbatim}
\end{mdframed}
In practice, you may want to use the \texttt{bind-then} form and backquote jointly to create functions. You use backquote to prevent the function from evaluating so that you can use it later, for example, in the \texttt{then} clause.

\begin{mdframed}[style=example]
\begin{verbatim}
  bind Some-practical-function fun` ~arg1 ~arg2 ~arg3,
    (~~do-something-with-the-arguments~~)
  then (Some-arg1 Some-arg2 Some-arg3 Some-practical-function)
\end{verbatim}
\end{mdframed}

\begin{mdframed}[style=hint]
  You can also use the punctuation sequence ``\texttt{,\textbackslash}'' to replace \texttt{fun`}.
\end{mdframed}

See \autoref{chap:examples} for concrete examples.

\subsection{Tail Recursive Function Calls}

Any practical functional programming language provides tail recursion optimization. So does Towel. However, Towel is unable to identify\footnote{\textit{I admit I had been lazy.}} whether a function call is tail recursive, so users are responsible for tagging tail recursive calls with an at symbol at the end of the name of the function, like this:

\begin{mdframed}[style=example]
\begin{verbatim}
  bind Loop fun` F It End,
    (It End - if=0 (It F),
                (It F F` It 1 + End Loop@)
  then (("looping" !println)` 1 10 Loop).
\end{verbatim}
\end{mdframed}

\subsection{Currying}

When applied with insufficient number of arguments, Towel will return a partially applied function instead of doing all the computation it is supposed to. To be more precisely, Towel copies the function being called as a new value, install the arguments already applied to that new function value, then return this new function value as the return value of the old function. \sout{Yummy!}

\begin{mdframed}[style=example]
\begin{verbatim}
  bind ~dec-1 (1 -)
  then ('The Answer is ' !print 43 ~dec-1 !println)
\end{verbatim}
\end{mdframed}

\subsection{Phony}

A phony in Towel, is a special value on stack. When a phony is the current TOS, the stack will be considered empty. To push a phony onto the current stack, use \mstd{\$\$}.

\begin{mdframed}[style=example]
\begin{verbatim}
  ($$ ife (true !println), (false !println))
\end{verbatim}
  This will print \texttt{true}.
\end{mdframed}

Often, phony is used in conjunction with currying to create a curried function.

\begin{mdframed}[style=hint]
  Note that every phony will be popped by the TVM right after it is used, otherwise it will shadow anything pushed before it. For example the following code can produce expected answer because of this feature:

\begin{verbatim}
  ([1 2 3 4 5] $$ 3 < /filter !println)
\end{verbatim}

The output will be \texttt{[4 5]}.
\end{mdframed}

\section{Bind Form}

Use bind forms to add new name bindings in a new scope. Names can be bound to any kind of values such as functions, atoms, and all kinds of literals as long as they exist on the stack.

Simply type \texttt{bind} followed by the name and the value. Use keyword \texttt{also} to bind more names to more values. Bind forms have a compulsory \texttt{then} clause, which is followed by a word. You can do your computation under the name scope after this name binding in the \texttt{then} clause. Top-level name bindings, i.e. names bound by the outmost bind form, are visible across modules, you may want to take advantage of this behavior.

\begin{mdframed}[style=example]
\begin{verbatim}
  bind A 40
  also B 2
  then (A B + !println)
\end{verbatim}
\end{mdframed}

\begin{mdframed}[style=detail]
  Binding in TVM is currently implemented as names associating to the absolute index of the values in the stack. See also the following warning.
\end{mdframed}

\begin{mdframed}[style=warning]
Note that all the computations are done on stacks, so are bindings. That is to say that, the values that get bound exists on stacks. So you may want to be careful about this.

You may overflow your stack by using the \texttt{bind-then} form in a series of tail recursive calls if you forget to pop the values you bind previously.\footnote{Tail recursive calls in Towel don't offer you a whole new stack (or to say erase the stack for you), but rather continue to use the same stack the caller have been using.}

Fasten your seat belts for the next two examples.

\begin{verbatim}
  bind Answer 42
  then (!!pop Answer !println)
\end{verbatim}

will result in your program blowing up, because the position where there used to hold the value for the Answer is now invalid.

What's more scare is this,

\begin{verbatim}
  bind Answer 42
  then (!!pop 41 Answer !println)
\end{verbatim}

You just accidentally changed the value of the Answer without even noticing it!
\end{mdframed}

\section{Module}

Modules, or namespaces, in Towel, are sets of names. Mechanisms like this prevent names of various files from colliding into each other.

\subsection{Importing a Module}

To import a module, use the \texttt{import} form.
\begin{mdframed}[style=example]
\begin{verbatim}
  import 'std' \
  import 'std' @
\end{verbatim}
\end{mdframed}

The first \texttt{import} form means importing the module defined in a file named \texttt{'std.w'}, and name that module \texttt{Std} so that you can reference to the names from this module as \mstd{SomeName}. The ending punctuation backslash is exactly the samething you use for module referencing. This is called explicit importing.

The second \texttt{import} form ending with an at symbol, means not only importing the module \texttt{Std}, but also importing all the exported names in that module. In this way, you are allowed to reference to the names without having to specify the modules they are in. This is call implicit importing.

\begin{mdframed}[style=detail]
  During compilation, the file the compiler searches is a \texttt{'.e'} file, this file contains only all the names available in the respective module.

  During execution, however, the file the virtual machine needs is a \texttt{'.w'} file which is the compiled version of the actual program.

  Also note that in current version of TVM, implicit importing imports and pushes all the exported values from the imported module onto the stack. So you may expect a non-empty stack after implicit importing.
\end{mdframed}

\begin{mdframed}[style=detail]
  Be aware that imports affects exactly the current scope, and the children scopes of the current one. When current scope exits, the side-effects the import form brought about are also gone.

  This also implies that values pushed by implicit importing are popped along with the stack being destroyed.
\end{mdframed}

\begin{mdframed}[style=hint]
  For your imformation, no module is imported by default. You have to explicitly import any modules you want to use.
\end{mdframed}

The path of the module file \texttt{'std.w'}, is searched as the following order:
\begin{itemize}
\item the current working directory
\item the predefined directory \texttt{towelibs}
\end{itemize}

\begin{mdframed}[style=detail]
  In current implementation, you can modify both the \texttt{'compiler/config.ml'} and \texttt{'vm/config.ml'} and recompile them to change the default search paths. We may add a environment variable for search paths in the future.
\end{mdframed}

Note that you can import multiple modules in a single \texttt{import} statement.

\subsection{Exporting Names}

You can also export names in your module so that they are visible to other modules with \texttt{export} form as follows:

\begin{mdframed}[style=example]
\begin{verbatim}
  bind A 1
  also B 2
  also C 3
  then export A B C @.
\end{verbatim}
\end{mdframed}

The Towel compiler will automatically generate a \texttt{'.e'} file for each compiled \texttt{'.t'} file for the purposes of name exportation.\footnote{Very much like the C header files, but less powerful.} An empty one will be generated, even if there are no names exported in the source file.

\section{Wait, What about Garbage Collection?}

Towel definitely collects garbage for you!

In current implementation of the TVM, when a value is popped out from a stack, the value gets GC'ed immediately.\footnote{Mayn thanks to OCaml!} When a stack is popped from the data stack stack, all the values on the popped stack are GC'ed immediately. So basically, Towel gets garbage collection for free because of its stack-based computation model.

Oh, and of course, extensions have to manage their own memory. Because they are out of the TVM's touch.

\section{Switches}
\label{sec:switches}

Towel provides some switches to change the default behavior of the compiler:
\begin{itemize}
\item \texttt{hungry}
\item \texttt{share-stack}
\item \texttt{optimize-seq}, on by default
\end{itemize}

If you want to turn on/off these switches, type in the switch names on first line, leave an empty line next to it, then go on with your code, like this:
\begin{mdframed}[style=example]
\begin{verbatim}
  I'm so hungry! Also please share-stack.

  bind Something-new (1 2 -)
  then Something-new
\end{verbatim}
\end{mdframed}

If \texttt{hungry} is turned on, \texttt{if} forms will be compiled to their respective hungry versions, which consume the TOS they test against when the test finishes, i.e. immediately after falling in particular branches or after failing to fall in any of the branches. This is useful when you want to be thrifty about stack spaces.

\begin{mdframed}[style=hint]
  You can also achieve this with \texttt{hungry} turned off by calling \mstd{!!pop} explicitly.
\end{mdframed}

When \texttt{share-stack} is on, every function (including sequence of course) uses the same stack, you get more classic stack-based language programming experience\footnote{And probably faster execution, because the context switching is done a lot faster without data stacks pushing and popping.} out of this switch, but you may want to make sure functions don't leave extra elements on the stack, so you'd better turn on \texttt{hungry} switch along with this.

If you turn on \texttt{optimize-seq} switch, when you create a sequence as the body of a function, \texttt{if} form, or \texttt{then} clause of \texttt{bind-then} forms, this sequence is optimized to disappear, leaving the body of it as the body of the form.

\begin{mdframed}[style=detail]
  The reason that I don't make them arguments to the compiler, is because I believe these kinds of configuration is a part of the code. If you were to make the arguments to the compiler, users with different compiler settings while compiling will have different bytecode, thus different result.
\end{mdframed}

\chapter{The Standard Library}

\section{Naming Conventions}

In towel, we encourage Lisp-like naming styles. But since only upper-cased characters are allowed to appear as the first alphabet character in a name, we normally prepend a punctuation to it.

\begin{itemize}
\item For routines, we would normally prepend an exclamation mark to
  such routines. For example, \mstd{!print}. For routines with serious side-effects, we prepend two.

\item For functions that operate on enumerables, we prepend \texttt{\#}.

\item For functional functions, we prepend a slash (half of the $\lambda$ character). For example, we have in the standard library \mstd{/foldl}, \mstd{/map}.

\item For predicates (something that returns \texttt{true} or \texttt{false}), we prepend a question mark.

\item For arithmetic functions, we don't prepend anything.

\item For arguments, we usually prepend a \texttt{\mtilde} for the sake of simplicity.
\end{itemize}

\section{Module \texttt{Std}}

Module \texttt{Std} is the very basic standard library of the Towel programming language. It consists of functions of multiple domains.

\subsection{Arithmetic Functions}

This category contains the following functions:
\begin{itemize}
\item \arithstd{+}

add \marg1 and \marg2
\item \arithstd{-}

\marg1 minus \marg2
\item \arithstd{*}

multiply \marg1 and \marg2
\item \arithstd{/}

divide \marg1 by \marg2
\item \arithstd{**}

\marg1 to the power of \marg2
\item \arithstd{\%}

\marg1 modulo \marg2
\end{itemize}

\begin{mdframed}[style=hint]
  This leftarrow thing is just to highlight the arguments that should be applied to the function, and implies the stack-based nature of Towel, i.e. the order the functions acquire their arguments.

  For example, \arithstd{-} means that \mstd{-} grabs \marg2 first, then \marg1, but still calculates $\marg1 - \marg2$.
\end{mdframed}

It also contains various functions for comparison purposes:

\begin{itemize}
\item \arithstd{=}

tests if \marg1 equals to \marg2
\item \arithstd{>}

tests if \marg1 is the greater than \marg2
\item \arithstd{>=}

tests if \marg1 is the greater than \marg2
\item \arithstd{<}

tests if \marg1 is the less than \marg2
\item \arithstd{<=}

tests if \marg1 is the less than or equal to \marg2
\item \arithstd{<>}

tests if \marg1 is not equal to \marg2
\end{itemize}

Let's not forget about bitwise arithmetic functions:

\begin{itemize}
\item \arithstd{:and}

bitwise and between \marg1 and \marg2
\item \arithstd{:or}

bitwise or between \marg1 and \marg2
\item \arithstd{:not}

bitwise not \marg1
\item \arithstd{:xor}

bitwise xor between \marg1 and \marg2
\item \arithstd{:shl}

bitwise shift left \marg1 for \marg2 bits
\item \arithstd{:shr}

bitwise shift right \marg1 for \marg2 bits
\item \arithstd{:lshr}

bitwise logical shift right \marg1 for \marg2 bits
\end{itemize}

\begin{mdframed}[style=hint]
  Arithmetic functions only work for numbers.

  The equality and non-equality function works for most of the types (including type \texttt{Type}).
  The comparison functions only work for numbers because they are implemented using the substraction function.

  Bitwise functions only work for fixed integer and unsigned fixed integer.
\end{mdframed}

\begin{mdframed}[style=hint]
  The above functions must be applied to values of the same type. Otherwise the TVM will throw an error and exit.
\end{mdframed}

\subsection{Conversion Functions}

Because Towel is a strong-typed language, we provide you some conversion functions to cast the values around.

\begin{mdframed}[style=warning]
  Think before you use these functions.
\end{mdframed}

\begin{itemize}
\item \marg1 \mla \mstd{\textasciitilde fint}

converts \marg1 of unsigned fixed integers, floats, big integers, or strings into a fixed integer
\item \marg1 \mla \mstd{\textasciitilde ufint}

converts \marg1 of unsigned fixed integers, floats, big integers, or strings into an unsigned fixed integer
\item \marg1 \mla \mstd{\textasciitilde int}

converts \marg1 of unsigned fixed integers, floats, big integers, or strings into a big integer
\item \marg1 \mla \mstd{\textasciitilde float}

converts \marg1 of unsigned fixed integers, floats, big integers, or strings into float number
\item \marg1 \mla \mstd{\textasciitilde str}

stringifies \marg1 of any possible value to a string
\end{itemize}

\subsection{Reflection Function}

Use \texttt{\string^?} if you want to know the type of a value at runtime. The return value of this function can be tested equality against other type values.

\subsection{Routines}

\begin{itemize}
\item \marg{x} \mla \mstd{!print}

prints \marg{x}
\item \marg{x} \mla \mstd{!println}

prints \marg{x} plus a newline character
\item \mstd{!read}

reads in a string from standard input and push it onto the stack
\item \mstd{!!pop}

pop the last element on current stack
\item \mstd{!!dup}

duplicate the last element on current stack
\item \texttt{...} \mla \marg{n} \mla \mstd{!!pack}

pack \marg{n} elements on current stack into a tuple
\item \marg1 \mla \mstd{!!unpack}

unpack \marg1 into N elements and push them onto current stack
\item \marg{fun} \mla \mstd{!invoke}

invoke \marg{fun} as a function when you don't know the arity of it
\end{itemize}

\begin{mdframed}[style=hint]
  Because of the low-levelness of \mstd{!!pack} and \mstd{!!unpack}, they do not accept argument the same way other functions do, but directly from current stack. So you cannot create curried functions out of them.
\end{mdframed}

\subsection{Phony}

Use \mstd{\$\$} to push a phony onto current stack.

\begin{mdframed}[style=warning]
  Do not try to \mstd{!!pop} a phony, it will result in an \texttt{PhonyEmptyStack} error.
\end{mdframed}

\subsection{Working with Enumerables}


\subsubsection{Functions that Works with Both Lists and Tuples}

Only one exists for now: \marg{x} \mla \mstd{?\#}, \marg{x} emptiness test.

\subsubsection{List-only Functions}

\begin{itemize}
\item \marg{l} \mla \mstd{\#hd}

get the head of \marg{l}
\item \marg{l} \mla \mstd{\#tl}

get the tail of \marg{l}
\item \marg{e} \mla \marg{l} \mla \mstd{\#cons}

cons \marg{e} and \marg{l} into a new list
\item \marg{l} \mla \mstd{\#rev}

reverse \marg{l}
\item \marg{l1} \mla \marg{l2} \mla \mstd{\#concat}

concatenate \marg{l1} and \marg{l2}
\item \marg{l} \mla \mstd{\#len}

get the length of \marg{l}
\end{itemize}

\begin{mdframed}[style=hint]
  Remember everything in Towel is immutable.
\end{mdframed}

\subsubsection{Tuple-only Functions}

\begin{itemize}
\item \marg{n} \mla \marg{t} \mla \mstd{\#tn}

get the \marg{n}-th element of \marg{t}
\item \marg{t} \mla \mstd{\#t1}

get the first element of \marg{t}
\item \marg{t} \mla \mstd{\#t2}

get the second element of \marg{t}
\item \marg{t} \mla \mstd{\#t3}

get the third element of \marg{t}
\end{itemize}

\subsection{Functional Functions}

\begin{itemize}
\item \marg{x} \mla \mstd{/id}

the identity function, i.e. it returns \marg{x}
\item \marg{init} \mla \marg{list} \mla \marg{fun} \mla \mstd{/foldl}

folds the  list\marg{list} from left to right on function \marg{fun}, with the initial value being \marg{init}
\item \marg{init} \mla \marg{list} \mla \marg{fun} \mla \mstd{/foldr}

same as \mstd{/foldl}, except that this walks the list from right to left and is not tail recursive function
\item \marg{list} \mla \marg{fun} \mla \mstd{/map}

maps function denoted by \marg{fun} onto \marg{list}
\item \marg{list} \mla \texttt{?pred} \mla \mstd{/filter}

for each element \marg{x} in \marg{list}, discards \marg{x} when \texttt{\marg{x} ?pred} turns out to be \texttt{true}
\item \marg1 \mla \marg2 \mla \marg{fun} \mla \mstd{/flip}

flips the arguments of a binary function \marg{fun}, i.e. \texttt{\marg2 \marg1 \marg{fun}}
\item \marg{args} \mla \marg{fun} \mla \mstd{/apply}

apply the elements in \marg{args} as arguments to \marg{fun}
\end{itemize}

\begin{mdframed}[style=hint]
  You may want to use backquotes when using these functions, for example,

\begin{verbatim}
  ([1 2 3 4 5] !println /map)
\end{verbatim}

prints out
\begin{verbatim}
  [1 2 3 4 5]
\end{verbatim}

rather than
\begin{verbatim}
  1
  2
  3
  4
  5
\end{verbatim}

To do this correctly, you should backquote \texttt{!println} like this

\begin{verbatim}
  ([1 2 3 4 5] !println` /map)
\end{verbatim}

This backquote prevents \texttt{!println} from executing, leaving it be as a function value so that it can be passed to \texttt{/map}.
\end{mdframed}

\section{Module \texttt{Random}}

This module exploits the extension mechanism provided by current implementation of the TVM to easily invoke functions in OCaml. See the virtual machine manual for more details.

The provided functions are
\begin{itemize}
\item \marg{s} \mla \texttt{\mtilde ~seed\textbackslash Random}

change the seed used in random number generation to \marg{s}
\item \texttt{\mtilde ~useed\textbackslash Random}

change the seed according to \texttt{/dev/urandom} on *nix systems, or system parameters if \texttt{/dev/urandom} is not available
\item \texttt{\mtilde ~\mtilde ~\textbackslash Random}

generates a random floating point number within the range of $[0.0, 1.0]$.
\end{itemize}


\chapter{Weaving a Towel Program}

The compiler for the Towel programming language is codenamed \texttt{weave}, you can find it in \texttt{build/src/compiler} after successfully compiling the whole project with
\begin{mdframed}[style=example]
\begin{verbatim}
  ./waf configure build --tvm --compiler --native
\end{verbatim}

\textit{*This will build both the compiler and the TVM. The built binaries are both standalone.}
\end{mdframed}

To compile a source file \texttt{foo.t}, and want the compiled output to be \texttt{bar.w}, use
\begin{verbatim}
        path-to-weave foo.t -o bar.w
\end{verbatim}

If you want to see the human-readable bytecode file, apply -t to \texttt{weave}, for example
\begin{verbatim}
        path-to-weave foo.t -o bar.l -t
\end{verbatim}

If you want to read the unassembled compiled file (human-readable) for debugging purposes, apply -r to \texttt{weave} like this
\begin{verbatim}
        path-to-weave foo.t -o bar.o -r
\end{verbatim}

If you have a human-readable bytecode file, and want to compile into VM-readable bytecode file, apply -b to \texttt{weave}, e.g.
\begin{verbatim}
        path-to-weave foo.l -o bar.w -b
\end{verbatim}

\begin{mdframed}[style=hint]
  Recommended extension for Towel source file is \texttt{.t}, because it's the first letter of the word \textit{towel}.

  Recommended extension for raw unassembled compiled file is \texttt{.o}, which means original Towel.

  Recommended extension for Towel bytecode file is \texttt{.w}, meaning woven Towel. It's also the third letter of \textit{towel}!\footnote{I love wordplay so much!}.

  By default, files that contains the exported names of the module have the extension of \texttt{.e}, meaning exportation.

  And finally recommended extension for human-readable bytecode file is \texttt{.l}.
\end{mdframed}

\chapter{Examples}
\label{chap:examples}

The following examples run under the default switch configuration.

\section{Concrete Examples}

\subsection{Greatest Common Divisor}
\begin{mdframed}[style=example]
\begin{verbatim}
  import 'std' @

  bind GCD fun` A B,
    (A B - if=0 A (5),
       if>0 (1) (!!pop A B - B GCD@ (2)),
       if<0 (!!pop (3) A B A - GCD@),
         ~idle (4))
  then (42 24 GCD !println)
\end{verbatim}
\end{mdframed}

\begin{enumerate}
\item See how \texttt{if} forms are chained here!
\item Note that we are tail recursing the \texttt{GCD} function here.
\item As is mentioned in previous chapters, when doing tail recursive calls, you really want to be careful about your stack usage to avoid stack leakage.
\item Remember an \texttt{if} form have two branches, and both of them cannot be omitted. So we put \sout{Eric Idle} \mstd{\mtilde ~idle} here to denote that we don't want to do anything here, just a placeholder.
\item The exit of the recursive function, so we'll directly put \texttt{A} here, without popping the result of \texttt{A B -}. Because this stack will be destroyed and all the values on it GC'ed, after it returns \texttt{A}.
\end{enumerate}

\subsection{Fibonacci Numbers}
\begin{mdframed}[style=example]
\begin{verbatim}
  bind Fib fun` A B N,
    (N if=0 A,
         (A B + A 1 N - Fib@))
  then (1 1 10 Fib)
\end{verbatim}
\end{mdframed}
Trivial.

\section{And Now for Something Completely Different...}

\subsection{Quicksort}
\begin{mdframed}[style=example]
\begin{verbatim}
  import 'std' @ (1)

  bind #quicksort (2) ,\ (3) L,
    (L ?#empty ift (!!pop (4) []), (!!pop
      bind ~h (L #hd)
      also ~t (L #tl)
      then (~t (~h >) (5) /filter #quicksort
            [~h]
            ~t (~h <=) /filter #quicksort
        #concat #concat (6))))
  then ([5 4 3 2 1] #quicksort !println)
\end{verbatim}
\end{mdframed}

\begin{enumerate}
\item Implicitly import module \texttt{Std} so that we can use the names bound in it without referencing to the module name.
\item Remember our naming conventions? Quicksort works on lists, so we prepend a \texttt{\#} to it.
\item It's a synonym for \texttt{fun`}.
\item Use \mstd{!!pop} to be thrifty about memory spaces.
\item Utilizing non-shared sequence to create partial applied function.
\item We have three lists on stack, so it takes two \mstd{\#concat}s to merge them all into one list.
\end{enumerate}

\subsection{Backquotes}
\label{ssec:backquote}
\begin{mdframed}[style=example]
\begin{verbatim}
  import 'std' \

  bind Sum ,\ ~ls,
    (0 ~ls +\Std` (1) /foldl\Std)
  then export Sum @
\end{verbatim}
\end{mdframed}

\begin{enumerate}
\item Be sure to quote this plus function (actually, the name) so that \mstd{/foldl} can use the addition function, rather than the value the function evaluated, and of course, in this case, you can never evaluate \mstd{+} with a number and a list.
\end{enumerate}

\subsection{(Fake) Macros}
\label{ssec:macro}
\begin{mdframed}[style=example]
\begin{verbatim}
  bind Macro1 (@ if~0 +, -)`
  also Macro2 {if~0 +, -}
  then bind Fun fun` A B,
         (A B Macro1)
       then (1 2 Fun).
\end{verbatim}
\end{mdframed}

A quick explanation: \texttt{(@ if\textasciitilde 0 +, -)} is bound to name \texttt{Macro1} as we want, which is essentially an anonymous function that tests whether the TOS of the caller's stack (because it's a shared sequence) is zero. The overall effect of this piece of code is like we have done a code replacement (at runtime).

\texttt{Macro2} is a short-hand version of \texttt{Macro1}.

\subsection{Object-oriented Programming}

\subsubsection{Not Even Close}

\begin{mdframed}[style=example]
\begin{verbatim}
  bind Class fun` ~init-value,
    bind ~data ~init-value
    then bind Accessor fun`, ~data (1)
         then [\ (2) Accessor` (3) ] (4)
  then bind Instance1-methods (41 Class)
       also Instance2-methods (42 Class)
       then bind Instance1-accessor (Instance1-methods #t1 (5))`
            also Instance2-accessor (Instance2-methods #t1)`
            then (Instance1-accessor !println
                  Instance2-accessor !println)
\end{verbatim}
\end{mdframed}

\begin{enumerate}
\item \marg{data} is captured by the \texttt{Accessor} function, which will be returned by the \texttt{Class} \textbf{function} (ha!), and you get all the public methods from the return value of this \texttt{Class} function as a tuple.
\item Maybe I should remind you that we use \texttt{[\textbackslash ~]} to denote a tuple
\item Don't forget to backquote you methods!
\item You can replace this \texttt{[\textbackslash Accessor`]} with \texttt{(1 !!pack)}.
\item Get the accessor function from the first slot of the tuple.
\end{enumerate}

The above code snippet will produce the output
\begin{verbatim}
  41
  42
\end{verbatim}

which is exactly what we would be expecting.

\subsubsection{A More Advanced Example}

\begin{mdframed}[style=example]
\begin{verbatim}
  import 'std' @

  bind >>send !invoke`

  also Shape ,\ ~type, (7)
    bind __type ~type
    also Type fun`, #t1 "dirty hack to make this work with >>send"
    also Area #t2`
    then [\__type [\Type` Area`]]

  then bind __meta-Shape ('' Shape)
       also :type (__meta-Shape #t2 #t1) (1)
       also :area (__meta-Shape #t2 #t2)

       also Circle ,\ Radius,
         bind __radius Radius (2)
         also ~super ('Circle' Shape) (3)

         then bind Type (~super #t1)
              also Area ,\, (__radius !!dup 3.14159 * *) (4)

              then [\Type` Area`] (5)

        also Rectangle ,\ Width Height,
          bind __width Width
          also __height Height

          also ~super ('Rectangle' Shape)

          then bind Type (~super #t1)
               also Area ,\, (__width __height *)
  
               then [\Type` Area`]

        then bind ~my-circle (42 Circle)
             also ~my-rectangle (1 2 Rectangle)
             then (~my-circle :type >>send (6) !println
                   ~my-rectangle :type >>send !println
                   ~my-circle :area >>send !println
                   ~my-rectangle :area >>send !println)
\end{verbatim}
\end{mdframed}

\begin{enumerate}
\item Make a meta object to get all the available messages a Shape object can receive.
\item A private field of Circle objects.
\item The superclass (or super object).
\item Implementing the abstract method!
\item The public available methods.
\item This is really great: we are sending the message \texttt{:type} to the Circle object \texttt{\mtilde ~my-circle}, and hoping the object will respond. \textit{Now we are speaking Japanese!}
\item So in retrospect, it's more like an interface or protocol (with some dirty hacks), rather than an abstract class.
\end{enumerate}

The key idea here is that the interface function returns a tuple of the indexing functions that specifiy the position of each method in classes that agree with this protocol.

For example, \texttt{:area} is actually the \texttt{\#t2} function, and is used to get the first element from a Shape object, which is a tuple with the second element being the function that does the calculation for area.

It's a shame that we don't have Lisp macros here, otherwise the syntax will be much simpler here.\footnote{Common Lisp actually has a package that does object-oriented programming simulation, which is of course much powerful than what I have shown here.}

\subsection{GUI Programming}

Here in this example, we will show you how to call functions from OCaml using the extension feature of the OCaml Towel Virtual Machine. This part is rather implementation specific. So be sure you are using the OCaml implementation of the Towel Virtual Machine.\footnote{Sure you are now!} For more on this topic, see also the chapter on Extending the Towel Virtual Machine in the Towel Assembly and Virtual Machine manual.

Below is the code listing of the OCaml-side wrapper for some Tk GUI functions. Notice how this wrapper interacts with the TVM via pushing and popping elements from \texttt{dss}, i.e. the data stack stack.

\begin{mdframed}[style=example]
  \begin{minted}{ocaml}
  open Tk;;
  open T;;
  open Ext;;
  open Nstack;;

  let top = ref None;;

  let widgets:(int, Widget.toplevel Widget.widget) Hashtbl.t = Hashtbl.create 512;;

  let tkfail msg = failwith (Printf.sprintf "TK failure: %s.\n" msg);;

  module SimpleTk : TowelExtTemplate =
  struct
    let extcall cn dss = match cn with
        1 -> top := Some(openTk ())
      | 2 -> mainLoop ()
      | 3 -> closeTk ()
      | 4 -> update ()
      | 5 -> let s = appname_get ()
        in dspush dss (OVString(s))
      | 6 -> let s = match (dspop dss) with
            OVString(x) -> x
          | _ -> tkfail "unsupported data type for appname_set"
        in appname_set s
      | _ -> tkfail "unimplemented call number"
  end

  let () = __ext__ := Some(module SimpleTk : TowelExtTemplate);;
  \end{minted}
\end{mdframed}

Then you may want to write a wrapper from Towel-side so that you can call the OCaml wrapper more conveniently.

\begin{mdframed}[style=example]
\begin{verbatim}
  import '.w' \

  bind ^~ ('ext_tk.cmo' !>ext\.w)
  also !>> !>>\.w`

  also >>tk fun`, (1u ^~ !>>)
  also ~~~ fun`, (2u ^~ !>>)
  also <<tk fun`, (3u ^~ !>>)

  also !set-tk-appname fun` ~s, (~s 6u ^~ !>>)

  then export >>tk ~~~ <<tk !set-tk-appname @
\end{verbatim}
\end{mdframed}

The choices of names are purely ideographic. For example, \texttt{>>tk} denotes that you are now entering the Tk world, i.e. the \texttt{openTk} function of OCaml.

With these two wrappers done, you can write a simple program to invoke the wrappers, like this

\begin{mdframed}[style=example]
\begin{verbatim}
  import 'simple-tk' @

  (>>tk
   'Hello, world by the Towel programming language!' !set-tk-appname
   ~~~
   <<tk)
\end{verbatim}
\end{mdframed}

You can read this example like this: first we enter the Tk environment, then set the Tk application name to \texttt{'Hello, blah blah...'}, after that we call the mainloop denoted by three consecutive tildes. When control returns from the mainloop, we now exit Tk environment by flowing from \texttt{tk}. You can of course design the API like this in callback fashion:

\begin{mdframed}[style=example]
\begin{verbatim}
  bind >>with-tk-env ,\ ~fun, (>>tk ~fun ~~~ <<tk)
  then (('Hello world!' !set-tk-appname)` >>with-tk-env)
\end{verbatim}
\end{mdframed}

If you compile the OCaml-side wrapper correctly and run the last but one example, you will get something like this:

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.75]{fig-gui.png}
  \caption{Hello world!}
  \label{fig:gui}
\end{figure}

\part{The Towel Assembly and Virtual Machine Manual}

\chapter{An Overview on the Towel Virtual Machine}

The Towel virtual machine is basically a stack-based state machine that accepts and executes Towel Assembly Language. It reads instructions sequently from instruction buffer and does its computation on stacks. It has the following important parts:
\begin{itemize}
\item execution stack (or the activation record stack): \texttt{ctx\_t list}\footnote{Note that, Towel Virtual Machine does not restricts itself to any single kind of implementation. The use of OCaml type notation here is for convenience and clarity.}
\item data stack stack: \texttt{value\_t dstack\_t dstack\_t}
\item flags record: \texttt{flags\_t}
\item module table: \texttt{(module\_id\_t, module\_t) Hashtbl.t}
\item extension table: \texttt{(module\_id\_t, module TowelExtTemplate) Hashtbl.t}
\end{itemize}

\section{Execution Stack}

Execution stack is where context of function calls are stored. A context of a function call consists the return address of the function call, the module id of the return address is in\footnote{The PC jumps around different instruction arrays of different modules.}, the function value of the function being called.

When a new function call is made, the context of this call is pushed onto the execution stack, followed by the instruction pointer jumping to the start position of the function, and the \texttt{curmod} field being switched to the target module. When the instruction \texttt{ret} is met, the function returns. TVM pops the TOS on execution stack and jumps to the return address stored in this TOS and switch back to the original module according to the \texttt{ctx\_t} value.

\begin{mdframed}[style=detail]
  Execution stack has one element in it initially. This context has no
  meaningful record fields.
\end{mdframed}

\section{Data Stack Stack}

Every function has a stack for itself to do its computation. This avoids stack corruptions along all the function executions. Data stack is essentially an important part of the context of the function call, but it is so important, we would like to operate them manually so that we could be more flexible.

Normally, when a new function call is made, a new data stack is pushed onto the data stack stack. When the function returns, TVM pops the TOS from the TOS of data stack stack (i.e. the return value of this function is the TOS of current function's data stack), pushes it onto the caller's stack (next to the TOS of data stack stack). Then this data stack gets popped, thus the caller's data stack is now the TOS of the data stack stack. TVM now pops and evaluates the TOS of the caller's data stack (this is a vital step) and pushes back the evaluated value.

\begin{mdframed}[style=detail]
  Data stack stack has one element (i.e. a data stack) in it
  initially, whereas the data stack has no elements whatsoever.

  Data stack stack is implemented by module \texttt{Nstack}, which
  provides the type \texttt{'a dstack\_t} (d for dynamic), and a lot
  of dedicated function for accessing the \texttt{dss} field in
  various ways.
\end{mdframed}

\section{Flags}

Flags stores the essential states for the virtual machine to run. For example, \texttt{is\_tail\_recursive\_call} records if the virtual machine is executing a tail recursive function. \texttt{curmod} records the current module whose instructions the PC is pointing at. \texttt{dss} is the data stack stack we talked about above. \texttt{scps} stores all the the names in scope stack (\texttt{scope\_t list}) for dynamic scoping.

\section{Module table}

Any functional Towel source code inevitably references (or, imports) other modules. When an \inst{import} is executing, a \texttt{module\_t} value is created and based on the module name, a UID is allocated for this module for referencing it later. Then the VM uses the UID as the key to store the \texttt{module\_t} value into the module table.

\subsection{Modules}

A module is a compiled Towel source code loaded into TVM, it has the following important fields:
\begin{itemize}
\item \texttt{id} of type \texttt{module\_id\_t}
\item \texttt{insts} of type \texttt{line array}
\item \texttt{exs} of type \texttt{(name\_t, value\_t) Hashtbl.t}
\item \texttt{imports} of type \texttt{(module\_id\_t, module\_id\_t) Hashtbl.t}
\end{itemize}

\texttt{exs} is the exported value table of the module, mapping from a name to a value.

\texttt{imports} is the absolute module id relative to this module. In the Towel compiler, names are resolved by a 2-tuple: the name id in the module and the module id. Because when compiling, the Towel compiler has no information about other modules other than the \texttt{.e} exportation file (like the header files you use in C). So it can only label other modules by IDs relative to itself (itself being zero).

When importing a new module, the module gets a global (absolute) id, all the referencing of this module should be made through this very id. So it's vital that every module maintains a mapping from the relative module id in its instructions to the absolute module id given by TVM. See \ref{fig:imports} for an intuitive illustration.

\begin{figure}[h]
\psscalebox{1 1} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-6.8)(12.02,6.8)
\psframe[linecolor=black, linewidth=0.04, dimen=outer](5.62,6.8)(0.42,-2.0)
\rput[bl](1.22,4.4){\texttt{push-name 0u 1u}}
\rput[bl](1.22,4.0){\texttt{push-name 0u 2u}}
\rput[bl](1.22,3.6){\texttt{push-name 0u 0u}}
\rput[bl](1.22,5.2){\texttt{import 'std' 1u}}
\rput[bl](1.22,4.8){\texttt{import 'random' 2u}}
\rput[bl](1.22,5.6){\texttt{...}}
\rput[bl](1.22,3.2){\texttt{...}}
\psframe[linecolor=blue, linewidth=0.04, dimen=outer](12.02,6.8)(7.62,1.2)
\rput[bl](2.02,-2.4){Your module}
\rput[bl](8.82,0.8){Module Std}
\rput[bl](8.02,5.6){\texttt{...}}
\rput[bl](8.02,5.2){\texttt{bind 0u}}
\rput[bl](8.02,4.8){\texttt{...}}
\rput[bl](8.82,0.4){\texttt{id = 5u}}
\rput[bl](0.82,6.4){\texttt{id = 1u}}
\psframe[linecolor=green, linewidth=0.04, dimen=outer](12.02,-0.4)(7.62,-6.0)
\rput[bl](8.02,-3.6){\texttt{...}}
\rput[bl](8.02,-4.0){\texttt{bind 0u}}
\rput[bl](8.02,-4.4){\texttt{...}}
\rput[bl](8.82,-6.4){Module Random}
\rput[bl](8.82,-6.8){\texttt{id = 3u}}
\psframe[linecolor=black, linewidth=0.04, dimen=outer](5.22,6.0)(0.82,2.8)
\psframe[linecolor=black, linewidth=0.04, dimen=outer](5.22,1.2)(0.82,-1.2)
\rput[bl](1.22,0.8){\texttt{1u -> 5u}}
\rput[bl](1.22,0.4){\texttt{2u -> 3u}}
\rput[bl](2.42,2.4){\texttt{insts}}
\rput[bl](2.42,-1.6){\texttt{imports}}
\psline[linecolor=blue, linewidth=0.04](4.02,4.4)(4.42,4.4)(4.42,1.6)(1.22,1.6)(0.82,1.6)(0.82,0.8)(1.22,0.8)(1.22,0.8)
\psline[linecolor=blue, linewidth=0.04](2.82,0.8)(7.22,0.8)(7.22,5.2)(7.62,5.2)(7.62,5.2)
\psline[linecolor=green, linewidth=0.04](4.02,4.0)(4.82,4.0)(4.82,2.0)(0.02,2.0)(0.02,0.4)(1.22,0.4)(1.22,0.4)
\psline[linecolor=green, linewidth=0.04](2.82,0.4)(7.22,0.4)(7.22,-4.0)(7.62,-4.0)(7.62,-4.0)
\end{pspicture}
}
\label{fig:imports}
\end{figure}

\section{Extension table}

Essentially the same thing as the module table, except that it stores extensions (of type \texttt{module Ext.TowelExtTemplate}) via \inst{load-ext}.

\renewcommand{\marg}[1]{\texttt{IARG\_#1}}
\newcommand{\sarg}[1]{\texttt{SARG\_#1}}
\newcommand{\parg}[1]{\texttt{PARG\_#1}}

\chapter{Towel Assembly Language and Its Instructions}

\section{Overview}

Towel Assembly Language has the same (or less) lexical elements as the Towel programming language. And it's grammar is very simple: each line of a Towel Assembly program has no or multiple labels, an instruction, and some arguments or no argument at all according to the instruction's arity.

After assembling, labels preceding a line are eliminated, and labels as arguments are replaced with their absolute position (i.e. the line number relative to the starting of the TAL source file, of the line where they appear as line labels).

Essentially, this assembly language is considered to be the intermediate representation of compiled Towel programs. And the TVM is a facility to execute IR directly. We can always compile IR further to, for example, native code or other virtual machines like JVM.

\subsection{Data Types}

\begin{itemize}
\item \texttt{VString}: a string surrounded by single quote
\item \texttt{VAtom}: an unsigned 64bit integer followed by an ``a''
\item \texttt{VUFixedInt}: an unsigned 64bit integer followed by a ``u''
\item \texttt{VFixedInt}: a signed 64bit integer
\item \texttt{VInt}: an integer of arbitrary precision followed by an ``l''
\item \texttt{VFloat}: a float number
\end{itemize}

\section{Scope-related Instructions}

\begin{mdframed}[style=hint]
  In the upcoming sections, we use the following convention to denote arguments of the instructions:

  \begin{itemize}
  \item \marg{SOME} means this argument is a part of an instruction.
  \item \sarg{SOME} means this argument is fetched from the data stack, and it will be put back potentially modified.

Stack argument that appears first is popped first, and so forth.

Also the term TOS and \sarg{SOME} are often interchangeable if there exists only one stack argument.
  \item \parg{SOME} is the same as \sarg{SOME}, except that \parg{SOME} is popped out from the stack forever.
  \end{itemize}
\end{mdframed}

\subsection{\texttt{0x01} \inst{push-scope}}

Pushes a new scope onto the scope stack.

\subsection{\texttt{0x02} \inst{pop-scope}}

Pops the TOS of the scope stack.

\subsection{\texttt{0x03} \inst{share-scope}}

Does absolutely nothing. Just a place-holder to indicate that this new context shares the same scope with its parent.

\subsection{\texttt{0x04} \inst{bind} \marg{UID}}

The argument \marg{UID} denotes the ID of the name that the TVM will bind TOS to. Then TVM does it in current scope.

\subsection{\texttt{0x05} \inst{fun-arg} \marg{UID}}

\inst{fun-arg} is a compound instruction\footnote{A compound instruction is an instruction with multiple side-effects.}. It steals (pops) from the caller's data stack\footnote{The second top stack of DSS, or the top stack of DSS if it's a tail recursive call.} and binds a reference to the value to the name indicated by the \marg{UID} in the clone of the \texttt{closure} table of the function.

\begin{mdframed}[style=detail]
  If the stack turns out to be empty, this instruction saves the
  name-value pairs already bound (arguments stole by previous
  \inst{fun-arg}s) in the copy of the closure of the current function
  (\texttt{curfun} of the TOS of ctxs), marks the function as partial
  and returns that function.

  Also if the stack is empty because the TOS is a phony, it removes the
  phony.
\end{mdframed}

\begin{mdframed}[style=hint]
  Why copy the \texttt{closure} table? Think about the execution of a recursive function,

\begin{verbatim}
  {ctx_current with arg1 = 5; arg2 = ?}
  {ctx1 with arg1 = 3; arg2 = 4}
  {ctx0 with arg1 = 1; arg2 = 2}
\end{verbatim}

If arguments were put into the table directly, applying arg2 with, for example, 10, in \texttt{ctx\_current} will result in \texttt{ctx1.arg2 <- 10} and \texttt{ctx0.arg2 <- 10}. In other words, you just corrupted the activation records.

So you may ask, why not putting the arguments directly on stack, and bind the given \marg{UID} to the index of that argument, just like what \inst{bind} does? The reason is that, if this is the case, it would be almost impossible to implement automatic currying. Because when returning the partial applied function, the stack that saves the arguments will be destroyed, and all your arguments will be lost.
\end{mdframed}

Sorry for such a complicated (and probably the only complicated) instruction.

\section{Stack-related Instructions}

\subsection{\texttt{0x10} \inst{push-fun} \marg{START}}

Makes a new function value and pushes it onto the stack without evaluating it. It takes \marg{START} as the start position of the function to be created. The module id of the function is considered to be \texttt{curmod.id}.

\subsection{\texttt{0x11} \inst{push-lnil} and \texttt{0x12} \inst{push-tnil}}

Makes a new list or tuple on top of the current data stack. TVM also puts the pointer of its content onto \texttt{flags.list\_make\_stack} to keep track where to put new values (such as values from \inst{push-lit}, \inst{push-lnil} or \inst{push-tnil}), when TVM reaches \inst{end-list} or \inst{end-tuple}, the ref on top of \texttt{flags.list\_make\_stack} is popped.

\begin{mdframed}[style=detail]
  Only selected instructions have effect on these list pointers:
  \begin{itemize}
  \item \inst{eval-and-push}
  \item \inst{push-lit}
  \item \inst{push-phony}
  \item \inst{push-name}
  \item \inst{push-fun}
  \item \inst{dup}
  \item Instructions that return some value.
  \end{itemize}
\end{mdframed}

\subsection{\texttt{0x13} \inst{end-list} and \texttt{0x14} \inst{end-tuple}}

Ends current list or tuple construction.

\subsection{\texttt{0x15} \inst{push-lit} \marg{LIT}}

Pushes a literal \marg{LIT} onto the stack or the list pointer on top of \texttt{flags.list\_make\_stack}.

\subsection{\texttt{0x16} \inst{push-name} \marg{NID} \marg{MID}}

Finds the value bound to the name whose ID is \marg{NID}, in the module with the module ID being \marg{MID}, then pushes it onto the stack.

\subsection{\texttt{0x17} \inst{eval-and-push} \marg{NID} \marg{MID}}

Takes two arguments as the description of a name (same as \inst{push-name}), finds the value it is bound to. If the value is a function, then evaluates the function.

\subsection{\texttt{0x18} \inst{pop} \parg{POPPED}}

Pops the TOS of current data stack. In other words, it gets an argument from the stack, then does absolutely nothing.

\subsection{\texttt{0x19} \inst{dup} \sarg{SOME}}

Duplicates the TOS of current data stack. In other words, it gets an argument from the stack, then puts back two.

\subsection{\texttt{0x1a} \inst{reverse} \parg{N} \sarg{1} \sarg{2} ... \sarg{N} (deprecated)}

Takes an argument from the stack, then reverses the \parg{N}-top most elements.

\subsection{\texttt{0x1b} \inst{unpack} \parg{E}}

Assumes the TOS is a list or tuple, then unpacks it onto the stack.

\begin{mdframed}[style=example]
\begin{verbatim}
  dsck: [ ... | [1 2 3]]
  after unpack: [ ... | 1 | 2 | 3]
\end{verbatim}
\end{mdframed}
\subsection{\texttt{0x1c} \inst{pack} \parg{N} \parg{1} \parg{2} ... \parg{3}}

Takes one integer \parg{N} from the stack to pack \parg{N} items on the stack into a tuple.

\begin{mdframed}[style=example]
\begin{verbatim}
  dsck: [ ... | 1 | 2 | 3 | 3]
  after pack: [ ... | [1 2 3]]
\end{verbatim}
\end{mdframed}

\begin{mdframed}[style=hint]
  If there were insufficient number of stack items, TVM throws an
  exception and terminates.
\end{mdframed}

\subsection{\texttt{0x1d} \inst{push-phony}}

Pushes a phony onto the stack that fakes an empty stack. That is to say, whenever TVM encounters a phony, it regards the stack as being empty.

\section{Function-related Instructions}

\subsection{\texttt{0x20} \inst{push-stack}}

Pushes a new data stack onto the data stack stack.

\subsection{\texttt{0x21} \inst{share-stack}}

Same as \inst{share-scope}.

\subsection{\texttt{0x22} \inst{pop-stack}}

Pops the current data stack.

\subsection{\texttt{0x23} \inst{eval-tail} \marg{NID} \marg{MID}}

Finds the function the two arguments references to, then calls it in a tail recursive manner.

\subsection{\texttt{0x24} \inst{ret} \sarg{RET\_VAL}}

Take care of the return value of the function. Pops the execution stack. And jumps to the return address.

\subsection{\texttt{0x25} \inst{shared-ret}}

Just sets the instruction pointer back to where this shared sequence gets called. No return value copied whatsoever (because there isn't any).

\subsection{\texttt{0x26} \inst{closure} \marg{NID} \marg{MID} \sarg{FUN}}

Assumes \sarg{FUN} is a function, takes two argument to describe the name \sarg{FUN} should capture.

\begin{mdframed}[style=detail]
  Because you only need to capture names from self-module, so \marg{MID} is often left being zero\footnote{The self-module ID, i.e. the ID modules reference themselves to.} when compiling.
\end{mdframed}

\subsection{\texttt{0xf2} \inst{install} \sarg{FUN}}

Install the captured names of \sarg{FUN} into current scope so that users can reference them.

\subsection{\texttt{0x27} \inst{invoke} \parg{FUN}}

Assumes TOS is a function, then invokes it. \parg{FUN} is popped before evaluating it.

\subsection{\texttt{0x28} \inst{call} \marg{START}}

Records $PC + 1$ as the return address, then jumps to \marg{START}.

\begin{mdframed}[style=hint]
  This instruction only jumps within the same module.
\end{mdframed}

\section{Conditional Branching Instructions}

\subsection{\texttt{0x30} \inst{jump} \marg{POS}}

Unconditionally jumps to \marg{POS}.

\subsection{\inst{j*} \marg{POS} \sarg{X}}

Tests the TOS with specific predicates. If the result is true, TVM jumps to \marg{POS}, otherwise, TVM executes the next instruction.

\inst{j*} instruction family consists of the following instructions:
\begin{itemize}
\item \texttt{0x32} \inst{jgz}: \sarg{X} is greater than zero,

\texttt{0x31} \inst{jgez}: \sarg{X} is greater than or equal to zero

\item \texttt{0x34} \inst{jlz}: \sarg{X} is less than zero,

\texttt{0x33} \inst{jlez}: \sarg{X} is less than or equal to zero

\item \texttt{0x35} \inst{jez}: \sarg{X} is equal to zero,

\texttt{0x36} \inst{jnez}: \sarg{X} is not equal to zero

\item \texttt{0x37} \inst{jt}: \sarg{X} is \texttt{true},

\texttt{0x38} \inst{jf}: \sarg{X} is \texttt{false}
\end{itemize}

\subsection{\inst{hj*} \marg{POS} \parg{X}}

Hungry versions of \inst{j*} instruction family, which consume the TOS they test against. Their \texttt{opcode}s are the ones of their non-hungry counterpart plus \texttt{0x10}. For example, the \texttt{opcode} of \texttt{jgz} is \texttt{0x42}.

\subsection{\texttt{0x39} \inst{je} \marg{POS}, \texttt{0x3a} \inst{jne} \marg{POS}}

Both of them test if the data stack is empty. \inst{je} jumps to \marg{POS} if it is empty, whereas \inst{jne} jumps only when the stack is non-empty.

\begin{mdframed}[style=detail]
  If \inst{je} is tested against a phony, it pops it before branching.
\end{mdframed}

\section{Arithmetic Instructions}

\subsection{\texttt{0x50} \inst{add}, \texttt{0x51} \inst{sub}, \texttt{0x52} \inst{mul}, \texttt{0x53} \inst{div}, \texttt{0x54} \inst{pow}}

Takes two arguments \parg{1} and \parg{2} from stack. Does arithmetic operations with \parg{1} and \parg{2}, and pushes \texttt{\parg{2} op \parg{1}}. These instructions work for all the number types\footnote{Atoms are not numbers.}.

\subsection{\texttt{0x55} \inst{mod} \parg{1} \parg{2}}

Does modulo operation between integer types.

\subsection{\texttt{0x56} \inst{equ} \parg{1} \parg{2}}

Does equality test on \parg{1} \parg{2}, and puts back \texttt{true} or \texttt{false} atoms.

\begin{mdframed}[style=hint]
  If two different types are tested against each other, TVM exits.
\end{mdframed}

\subsection{Bitwise Instructions}

Fixed integers, unsigned fixed integers, and big integers are supported by the following bitwise arithmetic operations:
\begin{itemize}
\item Bitwise and, \texttt{0x57} \inst{and} \parg{1} \parg{2}
\item Bitwise or, \texttt{0x58} \inst{or} \parg{1} \parg{2}
\item Bitwise xor, \texttt{0x59} \inst{xor} \parg{1} \parg{2}
\item Bitwise not, \texttt{0x5a} \inst{not} \parg{1}
\item Bitwise shift left, \texttt{0x5b} \inst{shl} \parg{X} \parg{N}
\item Bitwise shift right, \texttt{0x5c} \inst{shr} \parg{X} \parg{N}
\item Bitwise logical shift right, \texttt{0x5d} \inst{lshr} \parg{X} \parg{N}
\end{itemize}

Note that \inst{not}, \inst{and} and \inst{or} also work on the \texttt{true} and \texttt{false} atoms.

\subsection{Conversion Instructions}

These instructions allow one type of TOS to convert into value of other types. They are of the following form:
\begin{itemize}
\item \texttt{0x62} \inst{to-fint} \parg{X}
\item \texttt{0x63} \inst{to-ufint} \parg{X}
\item \texttt{0x64} \inst{to-int} \parg{X}
\item \texttt{0x65} \inst{to-float} \parg{X}
\item \texttt{0x66} \inst{to-str} \parg{X}
\end{itemize}

\section{Instructions for Enumerables}

\subsection{\texttt{0x5e} \inst{car} \parg{XS}}

Does CAR operation on linked lists. It takes a list from the stack, puts back the head of the list.

\subsection{\texttt{0x5f} \inst{cdr} \parg{XS}}

Same as \inst{car}, except that it puts back the rest of the list.

\subsection{\texttt{0x60} \inst{cons} \parg{XS} \parg{X}}

Does CONS operation on linked lists. It constructs a new list and then puts it back onto the stack.

\begin{mdframed}[style=hint]
  If it encounters a tuple, TVM exits.
\end{mdframed}

\subsection{\texttt{0x61} \inst{list-empty} \parg{XS}}

Tests if the TOS is an empty \textbf{list or tuple}. It puts back whether \texttt{true} or \texttt{false}, depending on the emptiness of the list or tuple.

\subsection{\texttt{0xf3} \inst{tuple-at} \parg{N} \parg{XS}}

Pushes back the \parg{N}-th element of \parg{XS}.

\section{I/O Instructions}

\subsection{\texttt{0x67} \inst{show} \parg{X}}

Prints the TOS to standard output.

\subsection{\texttt{0x68} \inst{read}}

Reads a string from standard input and store that string on the stack.

\section{Extension Instructions}

\subsection{\texttt{0xf1} \inst{load-ext} \parg{EXT\_STR}}

Loads the extension by the filename of \parg{EXT\_STR} from filesystem, and records it in the \texttt{opened\_exts} table. Then puts back the handle to that extension module.

\subsection{\texttt{0xf0} \inst{extcall} \parg{EXT\_ID} \parg{EXT\_CN}}

Takes two unsigned integers from the stack. Argument \parg{EXT\_ID} is for specifying the extension module handle, the other one is the call number to indicate which routine to call from the extension.

\section{Miscellaneous Instructions}

\subsection{\texttt{0x70} \inst{import} \parg{MOD\_STR} \marg{REL\_ID}}

Finds the module by the filename of \parg{MOD\_STR} and assign it's ID relative to current ID as \marg{REL\_ID}\footnote{See previous section on modules for more details.}.

TVM will assign a unique ID to every module imported based on this \parg{MOD\_STR}. For example, the module string of module \texttt{Std} from the Towel standard library (or Towelib) is \texttt{'std'} (because the source filename of it is \texttt{'std.t'}).

\subsection{\texttt{0x7f} \inst{export} \marg{UID}}

Exports the value bound by the name ID \marg{UID} to the module's \texttt{exs} field.

\subsection{\texttt{0x71} \inst{dint}}

Invokes the debug interrupt handler. See also \url{https://github.com/qwert42/ketivm/blob/master/vm/keti.py#L164}, which is an implementation of a similar instruction.

\subsection{\texttt{0x72} \inst{type} \parg{X}}

Pushes the type information of TOS onto the stack. This instruction only recognizes built-in types.

\subsection{\texttt{0xff} \inst{not-implemented}}

Prints an error message stating that an unimplemented instruction was found and the virtual machine has to exit.

\subsection{\texttt{0x0} \inst{idle}}

Does absolutely nothing.

\subsection{\texttt{0xfe} \inst{terminate}}

Terminate the Towel Virtual Machine. Or when finishing importing modules, go back to original module.

\begin{mdframed}[style=hint]
  Look at the similarities between (\inst{call}, \inst{invoke},
  etc. \texttt{->} \inst{ret}) and (\inst{import} \texttt{->}
  \inst{terminate}).
\end{mdframed}

\chapter{Bytecode Form of the Towel Assembly Language}

\section{Bytecode Form Overview}

A Towel Assembly Language source code can be compiled into a binary file. The layout of such a binary file is as follows:
\begin{itemize}
\item Magic number \texttt{0x4242}, denotes that this is a Towel binary
\item The data segment, which contains all the literals used in the original source code
\item Magic number \texttt{0xff3080ff}, denotes that data segment ends here
\item The code segment
\end{itemize}

\section{Data Segment}
A Towel binary contains only one data segment. Data segment contains all the literals used in the original source code file, which are of type \texttt{VString}, \texttt{VAtom}, \texttt{VFixedInt}, \texttt{VUFixedInt}, \texttt{VInt}, \texttt{VFloat}.

To store a string in the data segment. First, put a tag\footnote{Actually a string.} \texttt{``s''} into the data segment. After that tag, put a little endian 32-bit unsigned integer which represents the length of the string. Then put the contents of the string after the 32-bit integer.

To store an atom, put a tag \texttt{``a''} and then an unsigned little endian 64-bit integer.

To store a fixed integer, put a tag \texttt{``f''}, then a signed little endian 64-bit integer.

An unsigned fixed integer is the same as an atom, except the tag is \texttt{``u''}.

To store an integer (i.e. big integer) or a float, put their respective tags (\texttt{``b''} for integer, \texttt{``n''}\footnote{``n'' for not a number.} for float) before their binary string representations.

\begin{mdframed}[style=example]
  For a float \texttt{3.14159}, the Towel literal binary
  representation is \texttt{6e07000000332e3134313539}.
\end{mdframed}


The order of the literals are put in the data segment is their respective labels.

\section{Instruction Format}

Any bytecode instruction is a little-endian 64 bit number. The first byte of the number is \texttt{opcode}. For unary instructions, the second up to eighth bytes consists of the argument label. For binary instructions, the second up to fifth bytes consists of the first argument label, while the rest (sixth to eigth, 3 bytes, less than the first argument) consists of the second argument label.

When encountered a bytecode instruction, use the argument labels (if any) to retrieve actual arguments from data segment, and then form the actual instruction.

\begin{mdframed}[style=example]
  Suppose we have the following bytecode file:

\begin{verbatim}
  BB
    s03000000std
    u0100000000000000
    u0200000000000000
    s12000000Hello, world
    u1500000000000000
  ff3080ff

  1501000000000000
  7002000000000000
  1703000000050000
  1504000000000000
  fe00000000000000
\end{verbatim}

First, we can identify this file as a Towel bytecode because the first two bytes are \texttt{0x4242}, i.e. \texttt{BB}.

We also know that there are 5 literals in the data segment:
\begin{enumerate}
\item a string: \texttt{'std'}
\item an unsigned fixed integer 1
\item an unsigned fixed integer 2
\item a string: \texttt{'Hello, world'}
\item an unsigned fixed integer 0x15
\end{enumerate}

Then, for the first instruction (8 bytes), we get \texttt{opcode} from the first byte, in this case, \texttt{0x15}, which is \inst{push-lit} with \marg{LIT}, so we reinterpret from the 2nd to the 8th byte as an integer, 1. And get an element from the data segment by the index of one, which turns out to be the \texttt{'std'} string.\footnote{Yes, the index of data segment starts from one.}

So we can finally reconstruct the first instruction to be \texttt{PUSH\_LIT('str')}.

Now let's look at the third instruction, we lookup the \texttt{opcode} \texttt{0x17} is \inst{eval-and-push} with \marg{NID} and \marg{MID}, so we reinterpret from the 2nd to the 5th byte as an integer, i.e. 3, and 6th to 8th as another integer, 5.

Thus the two arguments are \texttt{2} and \texttt{0x15}. So we can also reconstruct this instruction to be\newline \texttt{EVAL\_AND\_PUSH(2, 0x15)}. The rest instructions are the same.

\end{mdframed}

\begin{mdframed}[style=detail]
  One of the neat things about this kind of representation is that I don't have to modify the assembler even when I have variable-sized instructions, because the addresses I'm jumping to are counted by instructions from the start, rather than bytes.
\end{mdframed}

\chapter{Extending the Towel Virtual Machine (OCaml Implementation)}

By using the Extension interface (in \texttt{src/vm/ext.ml}), you can easily add new functionalities to TVM, enabling more powerful Towel programming experience.

\section{Prerequisite}

The library (no matter if it's third-party, or of your own) should be \textbf{OCaml-compliant}, because TVM is built on top of OCaml too. That is to say, you should be able to write OCaml programs with it, thus TVM will have access to it via dynamic linking.

\begin{mdframed}[style=hint]
  I think plain C libraries with only thin OCaml wrappers (no
  \texttt{ml} files) would work too. Because \texttt{Dynlink} only
  needs it to be a OCaml-aware shared-library.
\end{mdframed}

\section{Approach}

Two instructions were implemented in TVM: \inst{load-ext} and \inst{extcall}.

\inst{load-ext} takes an \texttt{ext\_str} from the stack and loads the corresponding extension module into TVM via the OCaml standard module \texttt{Dynlink}. An \texttt{ext\_str} is a filename of the OCaml object file. After successfully loading it, the instruction leaves an unsigned integer (\texttt{OVUFixedInt}) on the stack for future reference of the extension.

\begin{mdframed}[style=hint]
   \texttt{ext\_str} should always ends with \texttt{.cmo} even if the target is a \texttt{.cmxs} file.
\end{mdframed}

\inst{extcall} takes two arguments from the stack: it first takes the TOS as the extension handle (the one \inst{load-ext} pushed), then it takes another unsigned integer as the extension function call number (although this integer will be converted into an OCaml \texttt{int}, but I think $2^{31}$ is fairly enough for ordinary libraries). The extension module then matches against the call number to determine which action to perform on the data stack.

\section{Howto}

\begin{mdframed}[style=hint]
  The following step illustrates how to build native extension rather
  than bytecode extension. If you want bytecode extension, use
  \texttt{ocamlc} instead, and probably lose some of the parameters.
\end{mdframed}

The first step, create a OCaml plugin. This plugin file is essentially a dynamic library (e.g. a \texttt{.so} file on *nix, a \texttt{.dll} file on Windows). When implementing this plugin, you must implement the module interface \texttt{TowelExtTemplate} laid out in \texttt{src/vm/ext.ml}. It's simple: one function - \texttt{extcall}. You will have to route individual call numbers to different routines using this function.

The first argument of \texttt{extcall} is the call number, then the second one is the \texttt{dss} of the VM, for you to get specific arguments from the data stack or leave your results on it. But be careful, if you ruin this dss, the TVM is doomed.

After you finish your \texttt{extcall} function and other local functions, remember to register your module value in the \texttt{\_\_ext\_\_} slot so that when loading this extension, TVM will get to know of your extension.

The second step, you compile your source code via the following command:

\begin{mdframed}[style=example]
  \texttt{ocamlfind ocamlopt -package \%1 \%2 -shared -linkall -I \%3
    -o \%4}
\end{mdframed}
Of these parameters:
\begin{itemize}
\item (\texttt{\%1}) the packages your extension module uses, take \texttt{ext\_random.ml} as an example, \texttt{\%1} will be replaced by stdint;
\item (\texttt{\%2}) the extension module source file, \texttt{ext\_random.ml}, for example;
\item (\texttt{\%3}) the directory where \texttt{t.cmi} and \texttt{nstack.cmi} are;
\item (\texttt{\%4}) the output binary filename, \texttt{ext\_random.cmxs}, for exmpale;
\item If you use some libraries that are not included in standard library, you may want to use \texttt{-linkpkg} instead of \texttt{-linkall} (for example, when building binding library for Tk).
\end{itemize}

The command for compiling the Random extension module is like this:

\begin{mdframed}[style=example]
  \texttt{ocamlfind ocamlopt -package stdint ext\_random.ml -shared
    -linkall -I ../../build/src/vm -o ext\_random.cmxs}
\end{mdframed}

Third, place the \texttt{.cmxs} file in the \texttt{libpaths} of TVM, default locations are current working directory and the folder \texttt{towelib}. Modify \texttt{src/vm/config.ml} to change these locations.

Last, write a Towel wrapper module for your extension module. In the \texttt{.w} instruction wrapper module, name \texttt{!>ext} is bound to the \inst{load-ext} instruction wrapper and name \texttt{!>>} for \inst{extcall}. You should always bind a name to the extension handle pushed by \texttt{!>ext}.


\begin{mdframed}[style=hint]
  It is often a good idea to bind a local partial applied function with the handle already applied to \texttt{!>>}.
\end{mdframed}

\end{document}
