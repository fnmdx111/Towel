
\documentclass{report}

\usepackage[left=1in, right=1in, top=1in, bottom=1in]{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{mdframed}
\usepackage{showexpl}
\usepackage[normalem]{ulem}
\usepackage{minted}
\usepackage{xltxtra}
\usepackage{appendix}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes, arrows, shadows}


\usepackage[usenames, dvipsnames]{pstricks}
\usepackage{epsfig}

\title{The Towel Report}
\author{Zihang Chen (zc2324) Baochan Zheng (bz2269) Guanlin Chen (gc2666)}

\makeatletter\@addtoreset{chapter}{part}\makeatother%

\mdfdefinestyle{detail}{%
rightline=true,innerleftmargin=10,innerrightmargin=10,
frametitle={Implementation Detail},
frametitlerule=true,frametitlerulecolor=white,
frametitlebackgroundcolor=cyan,
frametitlerulewidth=2pt}

\mdfdefinestyle{hint}{%
rightline=true,innerleftmargin=10,innerrightmargin=10,
frametitle={Hint},
frametitlerule=true,frametitlerulecolor=white,
frametitlebackgroundcolor=yellow,
frametitlerulewidth=2pt}

\mdfdefinestyle{example}{%
rightline=true,innerleftmargin=10,innerrightmargin=10,
frametitle={Example},
frametitlerule=true,frametitlerulecolor=white,
frametitlebackgroundcolor=green,
frametitlerulewidth=2pt}

\mdfdefinestyle{cl}{%
rightline=true,innerleftmargin=10,innerrightmargin=10,
frametitle={Code Listing},
frametitlerule=true,frametitlerulecolor=white,
frametitlebackgroundcolor=magenta,
frametitlerulewidth=2pt}

\mdfdefinestyle{warning}{%
rightline=true,innerleftmargin=10,innerrightmargin=10,
frametitle={Be warned!!},
frametitlerule=true,frametitlerulecolor=white,
frametitlebackgroundcolor=red,
frametitlerulewidth=2pt}

\newcommand{\mstd}[1]{\texttt{#1\textbackslash Std}}
\newcommand{\mtilde}[1]{\textasciitilde}

\newcommand{\marg}[1]{\texttt{\mtilde ~#1}}
\newcommand{\mla}[0]{~$\leftarrow$ ~}
\newcommand{\arithstd}[1]{\marg{1} \mla \marg{2} \mla \mstd{#1}}

\newcommand{\inst}[1] {\texttt{inst:#1}}


\begin{document}
\maketitle

\vspace{10cm}
\begin{figure}
\centerline{\includegraphics[scale=0.75]{images.jpg}}
\end{figure}
\newpage

\tableofcontents

\chapter{Language Overview}\label{chap:overview}

Towel is a stack-based, general-purpose, postfix-syntaxed, dynamically strong-typed, functional, language targeted at the Towel Virtual Machine.

\section[Stack-based]{Stack-based\footnote{It's not only stack-based, it's actually stack-stack-based. See also \autoref{sec:basics}.}}

Although stack-based programs are hard to reason about, it's really efficient and powerful to use once you get the gist of it. It is comes with natural support for imperative programming paradigm. It also enforces programmer's to think about the evaluation order of their potentially side-effected code.

\section{General-purpose}

Towel is designed with the universe in mind. So the syntax of it is expressive and reasonable with as few limitations as possible, yet easy to understand.

\section{Postfix-syntaxed}

The relationship between postfix syntax and stacks is just like a towel to a hitchhiker, so why not?

\section{Dynamically Strong-typed}

This means that Towel maintains types at runtime with no implicit type castings whatsoever, the compiler does not do type checking. However, it does scope analysis for every piece of Towel code.

\section{Functional}

Once you have full-fledged functional framework, you have the whole world. For example, Church booleans, Church numbers, etc. Or more realistic, you can use functions to emulate records, or even object-oriented programming!

\section{Towel Virtual Machine}

Why a virtual machine? Because we think this is the most portable and easy way to do a prototype for a new language. After you got the language working, you can do all kinds of crazing things, like compiling the bytecode that the VM reads into a native application.

\part{The Towel Reference Manual}

\chapter{Lexical Elements}\label{chap:grammar}
\section{Keywords}

Keywords in the Towel programming language is as follows:
\begin{verbatim}
if>=0 if>0 if<=0 if<0 if~0 if=0 ift iff ife ifne
match fun bind type also then export import ,\
\end{verbatim}

\section{Punctuations}

Punctuations used in the Towel programming language are as follows:

\begin{itemize}
\item Whitespace characters are simply ignored.
\item These characters have special meanings in the Towel programming language: \texttt{` ' `` , ; ( ) [ ] { } \char`\\ ~  @ EOF}. This means that you cannot use these characters in names and atoms. \footnote{In other words, you can use any other punctuation characters in names and atoms.}
\item Any unprintable character is reserved and won't be used.
\end{itemize}

\section{Names}

Names are used for naming (or to be more precise, referencing to) values. Valid names should not start with reserved punctuations, lowercased letters, and numbers.

More formally,
\begin{verbatim}
  unprintables ::= [all the unprintable ASCII characters]
  whitespaces ::= ['\n' '\t' ' ' '\r']
  reserved_punct ::= ['`' ''' '"' ',' ';' '\' '@' 
                      '(' ')' '[' ']' '{' '}' whitespaces unprintables]
  valid_punct ::= ['!' '~' '#' '$' '%' '^' '&' '*' '-' '_' '+' '=' '|'
                   ':' '<' '>' '?' '/']
  BQUOTE ::= '`'
  SQUOTE ::= '''
  DQUOTE ::= '"'
  COMMA ::= ','
  SEMICOLON ::= ';'
  PERIOD ::= '.'
  SLASH ::= '\'
  AT ::= '@'
  LPAREN ::= '('
  RPAREN ::= ')'
  LBRACKET ::= '['
  RBRACKET ::= ']'
  LBRACE ::= '{'
  RBRACE ::= '}'

  digit ::= ['0'-'9']
  hexdigit ::= ['0'-'9' 'a'-'f' 'A'-'F']
  bindigit ::= ['0'-'1']
  lc_chars ::= ['a'-'z']
  NAME ::= [^ '-' reserved_punct digit lc_chars] [^ reserved_punct]*
\end{verbatim}

You can also resolve names in other namespaces (what we call \textit{modules} in Towel) by concatenating them with a backslash.

\begin{mdframed}[style=example]
If you would like to access the name \texttt{+} in module \texttt{Std}, which is in module \texttt{MyStdlib}, you can write:

\begin{verbatim}
+\Std\MyStdlib
\end{verbatim}

\end{mdframed}

\section{Literals}

Most easy-to-use languages support a wide variety of literals (Python is a good example and Java is not). The Towel programming language supports literals for atoms, integers (fixed, unsigned fixed, big), floats, strings, lists and tuples. They are defined as follows (rule for list literals will be revealed later):
\begin{verbatim}
  ATOM ::= lc_chars [^ reserved_punct]*

  signed ::= ['+' '-']
  fint_body ::= (("0d"? digit+) | ("0x" hexdigit+) | ("0b" bindigit+))
  FINT ::= signed? fint_body
  INT ::= signed? digit+ ['L' 'l']
  UFINT ::= '+'? fint_body ['U' 'u']

  dot ::= '.'
  int ::= digit+
  frac ::= digit+
  exp = 'e' signed? int
  dot_float = ((dot frac) | (int dot frac)) exp?
  exp_float = int (dot frac)? exp
  FLOAT ::= signed? (dot_float | exp_float)

  string_char ::= [^ '\' ''']
  string_esc_seq ::= '\' string_char
  string_item ::= string_char | string_esc_seq
  STRING ::= ''' string_item* '''
  (Rules for strings is from the lexical parsing section of the Python
   language reference manual.)
\end{verbatim}

\begin{mdframed}[style=detail]
Because positive (or negative) numbers, ``+1.'' for example, also uses the plus punctuation, \texttt{NAME} is actually more complicated than what's written above:
\begin{verbatim}
  NAME ::= valid_upper_char common_valid_char*
         | '+' common_valid_char_no_digits?
         | '+' common_valid_char_no_digits common_valid_char*
         | '-' common_valid_char_no_digits?
         | '-' common_valid_char_no_digits common_valid_char*
\end{verbatim}
\end{mdframed}

\section{Comments}

Comments are defined as follows:
\begin{verbatim}
  __COMMENTS ::= '"' [^ '"']* '"'
\end{verbatim}

\section{Lexical Error}

When the scanner encounters any other character not mentioned above, it will raise a \texttt{LexicalError} exception.

\chapter{Data Types}
\label{chap:data-types}

This chapter covers the basics on types in Towel. It worth mentioning here that all the values of whatever types of Towel is immutable.

\section{Built-in Types}

Towel provides to the user the following primitive built-in types:
\begin{itemize}
\item Atom
\item Fixed integer or, FixedInt
\item Unsigned fixed integer or, UFixedInt
\item Big integer or, Int
\item String
\item Float
\item List
\item Tuple
\end{itemize}

\subsection{Functions}

Functions are one of the most important kind of values in Towel. They can be returned as values, passed as arguments, and evaluated as regular functions. This kind of feature is often called as \textit{functions as first-class citizens}. A function gets its argument from caller's data stack (often the data stack beneath it, or the same stack if it's a tail recursive call), and returns the TOS on its data stack.

\begin{mdframed}[style=hint]
Although it is not recommended, you can always use the \mstd{!!pack} routine\footnote{A routine in Towel is a function with side-effects (or stack-effects).} to pack multiple values in the callee and \mstd{!!unpack} them in the caller to achieve multiple return values.
\end{mdframed}

\subsection{Atoms}

Atoms are special names uniquely bound to integer constants. But they are not comparable to integers, nor can they be applied to numeric operations. It's also meaningless to compare between two atoms.

Towel predefines \texttt{false} and \texttt{true} as boolean atoms.

\begin{mdframed}[style=detail]
Although they are not comparable to integers, they can be tested against each other to see if they are the same. The earlier the atom appears in code, the smaller the integer constants it gets.
\end{mdframed}

\subsection{\texttt{(U)FixedInt}s, \texttt{Int}s, \texttt{Float}s}

(Unsigned) fixed integers and floats are 64bit integers and floats. \texttt{Int}s are signed integers of arbitrary precision (like those \texttt{int}s in Python). These types are said to be subclass of the class \texttt{Number} (only conceptually), which is to say all these types are supported by basic arithmetic operations. However, bitwise operations will only take (\texttt{U})\texttt{FixedInt}s as arguments.

\subsection{Strings}

A string is an immutable data structure of fixed-length sequence of characters (or bytes).

\begin{mdframed}[style=detail]
  To see how long a string can be in the underlying OCaml environment, go to your OCaml toplevel and type \texttt{Sys.max\_string\_length;;}.
\end{mdframed}

\subsection{Lists and Tuples}

Lists and tuples are enumerable types in Towel.

Lists are accepted by list-related functions, such as \mstd{\#hd}, \mstd{\#tl}, \mstd{?\#} (list emptiness test). However, note that only lists are supported by the \mstd{\#cons} operation. When you \mstd{\#cons} to a tuple, Towel Virtual Machine will blow up.

Tuples are accepted by \mstd{\#tn} to access specific element of them. They can also be tested emptiness with \mstd{?\#}.

\section{Conversion between Types}

Most of the operations can only deal with homogeneous data types. For example, addition can only happen between two fixed integers, or two unsigned fixed integers, or big integers, etc. A addition between a float and an integer will result in error.

If you really would like to add a float to an integer, either use the built-in function \mstd{\mtilde ~float} to convert the integer into a float, or use \mstd{\mtilde  ~int} to convert the float into an integer.

\section{Runtime Type Reflection}

You can use the built-in function \mstd{\string^?} to get the type of TOS. The returned type is a built-in value that represents types. Type values can be test against each other for equality with \mstd{\string=}.

\chapter{Hello, Word}
\label{chap:forms}

\section{Program Structure}\label{sec:basics}

A Towel program consists of one or multiple so-called \textbf{words} or \textbf{forms}.

When encountered multiple words, they are always evaluated one by one in the order they appear. Although most of the times, Towel remains in a postfix fashion, but for the sake of convenience, some parts of the grammar is of prefix or infix style (e.g. the bind form and namespaced name invocation).

A word, can be one of the following:
\begin{itemize}
\item literal
\item name
\item sequence
\item backquote
\item \texttt{if} forms
\item function form
\item bind form
\item import and export form
\end{itemize}

You should also know that the computational model Towel uses is based on stacks, or to put it more precisely, stack of stacks. That is to say, when you invoke a function, a new stack in created for that particular function, and after it returns the new stack gets destroyed. This avoids potential corruption of only a single stack.

\section{Rules for Evaluation}

When you reference to a word, Towel does the following:
\begin{itemize}
\item For literals, it pushes back them directly;
\item For a backqoute, it pushes back whatever is quoted (i.e. without evaluating);
\item For a function, it creates a new stack, gets whatever required arguments to it from caller's stack, does the computation, pushes back the TOS of its own stack to caller's stack (this is called in Towel ``returning a value'');
\item For a sequence, it creates a new function out of the body of the sequence and evaluates that function;
\item For a name, it looks up the value it references to, evaluates that value and pushes back the evaluated value.
\item For \texttt{if} forms, test against the TOS and evaluate the word in respective branch;
\item For bind-then form, it pushes a new scope, evaluates the values on stack that get bound (both \texttt{bind} clause and \texttt{also} clause) and binds the values evaluated to the names, then it evaluates the \texttt{then} clause within current scope. Finally it pops the scope.
\end{itemize}

\section{Rules for Scoping}

Only two forms in Towel can create a new scope: the function form and the \texttt{bind-then} form. This means that a scope is created when entering a function, or a \texttt{bind-then} form, and implies that a scope is destroyed when exiting a function, or a \texttt{bind-then} form.

A name is only referenceable within the scope it is bound, plus the child scopes of that scope. For closures, the captured names are poured into the function's scope by default.

\section{Literals}

A literal is a literal value whose type is of the data types we have talked about in \autoref{chap:data-types}.

\subsection{Atoms}

You can create atoms by writing any lowercased letter followed by arbitrary length of characters that are not reserved punctuations and keywords.

Atoms are unique across the entire program. Because atoms are assigned with a unique unsigned 64-bit integer, so you can have no more than $2^{64}$ of them in your program.

\begin{mdframed}[style=detail]
  Boolean type is implemented as atoms. \mstd{:and}, \mstd{:or}, \mstd{:not} work for integers as well as booleans.
\end{mdframed}

\subsection{Numbers and Strings}

You can create number and string literals by writing like this:
\begin{mdframed}[style=example]
\begin{verbatim}
  1 -1 2 -3 5 -8 13 -21
  +4242424242424242424242424242424242424242424242424242424242L
  -3141592653589793238462643383279l
  3U +0x4579u 0b11101 0d1234
  1.1e1 -0.1 'don\'t panic'
\end{verbatim}
\end{mdframed}

Note that string items are surrounded by single quote, rather than double quote.\footnote{Because you don't have to hit the \textit{shift} key when inputing single quotes. Same goes for brackets.}

\subsection{Lists}

When creating a list literal, you must write a list of words separated with spaces in a pair of brackets, like the following code:
\begin{mdframed}[style=example]
\begin{verbatim}
  [arthur-dent ford-prefect betelgeuse]
  [Spam Spam Spam]
  [Spam ifne (More Spam)`, (Less Spam)`] (valid but bad example)
\end{verbatim}
\end{mdframed}

\begin{mdframed}[style=warning]

Although you can safely write list literals with names, and literals (integers, atoms, or even list), but because of Towel's stack-based nature, complicated words in a list literal may not turn out to be what you want.

When the Towel compiler compiles a list literal into instructions, it first generates a pair of instructions called \texttt{push-lnil}, \texttt{end-list}. Then it compiles the words being the content of the list literal, and put the generated code between that pair of instructions. But be warned that, when entering the \texttt{push-lnil} and \texttt{end-list} pair, the target of most of the pushing actions will be come the newly pushed list, rather than the data stack. For example,

\begin{verbatim}
  push-lnil
  push-lit 1u
  push-lit 2a
  push-lit 3l
  end-list
\end{verbatim}

will result in \texttt{[1 2 3]}. And

\begin{verbatim}
  push-lnil
  push-lit 1u
  push-lnil
  push-lit 2a
  push-lnil
  push-lit 3l
  end-list
  end-list
  end-list
\end{verbatim}

will result in \texttt{[1 [2 [3]]]}. Just like what we expected, right?

But consider the following,

\begin{verbatim}
  (2 3 [1 2 +] !println)
\end{verbatim}

This is syntactically correct Towel, but the problem is that it tries to evaluate a function within the environment of creating a list. The user might expect the output being \texttt{[3]} but that not the case: before the name \texttt{+}, the stack is like the following,

\begin{verbatim}
  {| 2 3 [1 2 |}
\end{verbatim}

when the addition function tries to grab its arguments, it first pop the unfinished \texttt{[1 2} as its argument, which is incorrect already. And it then gets its second argument from the stack, which is obviously 3.

You should also be very cautious with

\begin{verbatim}
  (1 2 [3 if>0 +`, -`])
\end{verbatim}

This \texttt{if>0} is tested against the TOS, which is the unfinished list \texttt{[3}!

So in general, never ever put complicated words in a list literal. If you are really forced to do so, enclose the word in a sequence (parentheses).
\end{mdframed}

\subsection{Tuples}

Tuples are fixed length lists, this means that you cannot CDR from them, nor CONSing to them. Create tuples like this:
\begin{mdframed}[style=example]
\begin{verbatim}
  [\ arthur-dent ford-prefect betelgeuse]
  [\] "an empty tuple"
\end{verbatim}
\end{mdframed}
\section{Sequence}

Sequences are short-hand forms for creating anonymous functions with no arguments. You can create a sequence by writing the sequence body between a pair of parentheses.

Towel also provides another kind of sequences, the shared sequences. This kind of sequences share the same context (such as stack and scope) with the caller. When creating such sequences, you add an at symbol right after the left parenthesis.

\begin{mdframed}[style=example]
\begin{verbatim}
  ((A B - if>0 1, 0) (A B + if<0 2, 3) :and) "non-shared regular sequences"
  (A B - (@ if>0, 1, 0) !println) "prints 1 or 0"
\end{verbatim}
\end{mdframed}

You may want to create a shared sequence when defining tail-recursive functions, otherwise, you lose the advantage of not stacking up contexts.

\begin{mdframed}[style=hint]
Just for your information, the Towel compiler automatically strips off the creation of certain unnecessary sequences for performance reasons. For example, the following sequences will be optimized out.

\begin{verbatim}
  bind THE-ANSWER 42
  then (THE-ANSWER !println)

  42 if>0 ('The answer is greater than void.' !println),
    ('The answer is less than void.' !println)
\end{verbatim}

The appearances of the sequences above are simply only of syntactical reasons, namely, to avoid ambiguity of the grammar. They can be safely removed semantically.

See \autoref{sec:switches} for more details.
\end{mdframed}

\section{Backquote}

Towel evaluates and pushes everything it encounters, you can use backquotes the values to prevent Towel from evaluating them so that Towel pushes them directly onto the data stack. Backquotes are created by appending a backquote to the words you want to backquote.

You can backquote only limit types of words:
\begin{itemize}
\item literals; Towel pushes the literal back immediately
\item names; Towel pushes whatever the name references to onto the stack, without evaluating them
\item sequences and functions; Towel pushes them onto the stack without executing it
\item backquotes; why would you do such a thing?
\end{itemize}

\begin{mdframed}[style=hint]
  You can create backquoted shared sequence by replacing the
  parentheses with braces and dropping both the at symbol and
  backquote. See also \autoref{ssec:backquote} and
  \autoref{ssec:macro}.
\end{mdframed}
\section{\texttt{if} Forms}

Towel supports 10 kinds of \texttt{if} forms for the sake of readability and convenience. They are of the same form, while differing in the predicate they use.

An \texttt{if} form contains two words separated by a comma. When evaluating an \texttt{if} form, Towel tests the TOS and see if it satisfies the condition. If the condition is satisfied, the first word (called the true branch) is evaluated and the second word is ignored\footnote{This is basically why you want a designated condition form}, and vice versa. By default, \texttt{if} forms does not consume TOS, see \autoref{sec:switches} for more detail.

The predicates used by \texttt{if} forms are as follows:
\begin{itemize}
\item \texttt{if>0}, if TOS is a number and greater than 0
\item \texttt{if>=0}, if TOS is a number and greater than or equal to 0
\item \texttt{if<0}, if TOS is a number and less than 0
\item \texttt{if<=0}, if TOS is a number and less than or equal to 0
\item \texttt{if=0}, if TOS is a number and equal to 0
\item \texttt{if\textasciitilde 0}, if TOS is a number and not equal to 0
\item \texttt{ife}, if the stack is empty
\item \texttt{ifne}, if the stack is not empty
\item \texttt{ift}, if TOS is an atom and equal to \texttt{true}
\item \texttt{iff}, if TOS is an atom and equal to \texttt{false}
\end{itemize}

See \autoref{chap:examples} for examples on \texttt{if} forms.

\section{Function Form}

Function forms are used to define anonymous functions of arbitrary arity. To define a function, first type the keyword \texttt{fun}, and a list of argument declarations and finally a word for the body of the function.

Because function form creates and evaluates function in place, the following code is valid\footnote{But not semantically correct, because you cannot invoke a number as function.}:
\begin{mdframed}[style=example]
\begin{verbatim}
  fun A B,
    (A B fun X, (3 X +))
\end{verbatim}
\end{mdframed}
In practice, you may want to use the \texttt{bind-then} form and backquote jointly to create functions. You use backquote to prevent the function from evaluating so that you can use it later, for example, in the \texttt{then} clause.

\begin{mdframed}[style=example]
\begin{verbatim}
  bind Some-practical-function fun` ~arg1 ~arg2 ~arg3,
    (~~do-something-with-the-arguments~~)
  then (Some-arg1 Some-arg2 Some-arg3 Some-practical-function)
\end{verbatim}
\end{mdframed}

\begin{mdframed}[style=hint]
  You can also use the punctuation sequence ``\texttt{,\textbackslash}'' to replace \texttt{fun`}.
\end{mdframed}

See \autoref{chap:examples} for concrete examples.

\subsection{Tail Recursive Function Calls}

Any practical functional programming language provides tail recursion optimization. So does Towel. However, Towel is unable to identify\footnote{\textit{I admit I had been lazy.}} whether a function call is tail recursive, so users are responsible for tagging tail recursive calls with an at symbol at the end of the name of the function, like this:

\begin{mdframed}[style=example]
\begin{verbatim}
  bind Loop fun` F It End,
    (It End - if=0 (It F),
                (It F F` It 1 + End Loop@)
  then (("looping" !println)` 1 10 Loop).
\end{verbatim}
\end{mdframed}

\subsection{Currying}

When applied with insufficient number of arguments, Towel will return a partially applied function instead of doing all the computation it is supposed to. To be more precisely, Towel copies the function being called as a new value, install the arguments already applied to that new function value, then return this new function value as the return value of the old function. \sout{Yummy!}

\begin{mdframed}[style=example]
\begin{verbatim}
  bind ~dec-1 (1 -)
  then ('The Answer is ' !print 43 ~dec-1 !println)
\end{verbatim}
\end{mdframed}

\subsection{Phony}

A phony in Towel, is a special value on stack. When a phony is the current TOS, the stack will be considered empty. To push a phony onto the current stack, use \mstd{\$\$}.

\begin{mdframed}[style=example]
\begin{verbatim}
  ($$ ife (true !println), (false !println))
\end{verbatim}
  This will print \texttt{true}.
\end{mdframed}

Often, phony is used in conjunction with currying to create a curried function.

\begin{mdframed}[style=hint]
  Note that every phony will be popped by the TVM right after it is used, otherwise it will shadow anything pushed before it. For example the following code can produce expected answer because of this feature:

\begin{verbatim}
  ([1 2 3 4 5] $$ 3 < /filter !println)
\end{verbatim}

The output will be \texttt{[4 5]}.
\end{mdframed}

\section{Bind Form}

Use bind forms to add new name bindings in a new scope. Names can be bound to any kind of values such as functions, atoms, and all kinds of literals as long as they exist on the stack.

Simply type \texttt{bind} followed by the name and the value. Use keyword \texttt{also} to bind more names to more values. Bind forms have a compulsory \texttt{then} clause, which is followed by a word. You can do your computation under the name scope after this name binding in the \texttt{then} clause. Top-level name bindings, i.e. names bound by the outmost bind form, are visible across modules, you may want to take advantage of this behavior.

\begin{mdframed}[style=example]
\begin{verbatim}
  bind A 40
  also B 2
  then (A B + !println)
\end{verbatim}
\end{mdframed}

\begin{mdframed}[style=detail]
  Binding in TVM is currently implemented as names associating to the absolute index of the values in the stack. See also the following warning.
\end{mdframed}

\begin{mdframed}[style=warning]
Note that all the computations are done on stacks, so are bindings. That is to say that, the values that get bound exists on stacks. So you may want to be careful about this.

You may overflow your stack by using the \texttt{bind-then} form in a series of tail recursive calls if you forget to pop the values you bind previously.\footnote{Tail recursive calls in Towel don't offer you a whole new stack (or to say erase the stack for you), but rather continue to use the same stack the caller have been using.}

Fasten your seat belts for the next two examples.

\begin{verbatim}
  bind Answer 42
  then (!!pop Answer !println)
\end{verbatim}

will result in your program blowing up, because the position where there used to hold the value for the Answer is now invalid.

What's more scare is this,

\begin{verbatim}
  bind Answer 42
  then (!!pop 41 Answer !println)
\end{verbatim}

You just accidentally changed the value of the Answer without even noticing it!
\end{mdframed}

\section{Module}

Modules, or namespaces, in Towel, are sets of names. Mechanisms like this prevent names of various files from colliding into each other.

\subsection{Importing a Module}

To import a module, use the \texttt{import} form.
\begin{mdframed}[style=example]
\begin{verbatim}
  import 'std' \
  import 'std' @
\end{verbatim}
\end{mdframed}

The first \texttt{import} form means importing the module defined in a file named \texttt{'std.w'}, and name that module \texttt{Std} so that you can reference to the names from this module as \mstd{SomeName}. The ending punctuation backslash is exactly the samething you use for module referencing. This is called explicit importing.

The second \texttt{import} form ending with an at symbol, means not only importing the module \texttt{Std}, but also importing all the exported names in that module. In this way, you are allowed to reference to the names without having to specify the modules they are in. This is call implicit importing.

\begin{mdframed}[style=detail]
  During compilation, the file the compiler searches is a \texttt{'.e'} file, this file contains only all the names available in the respective module.

  During execution, however, the file the virtual machine needs is a \texttt{'.w'} file which is the compiled version of the actual program.

  Also note that in current version of TVM, implicit importing imports and pushes all the exported values from the imported module onto the stack. So you may expect a non-empty stack after implicit importing.
\end{mdframed}

\begin{mdframed}[style=detail]
  Be aware that imports affects exactly the current scope, and the children scopes of the current one. When current scope exits, the side-effects the import form brought about are also gone.

  This also implies that values pushed by implicit importing are popped along with the stack being destroyed.
\end{mdframed}

\begin{mdframed}[style=hint]
  For your imformation, no module is imported by default. You have to explicitly import any modules you want to use.
\end{mdframed}

The path of the module file \texttt{'std.w'}, is searched as the following order:
\begin{itemize}
\item the current working directory
\item the predefined directory \texttt{towelibs}
\end{itemize}

\begin{mdframed}[style=detail]
  In current implementation, you can modify both the \texttt{'compiler/config.ml'} and \texttt{'vm/config.ml'} and recompile them to change the default search paths. We may add a environment variable for search paths in the future.
\end{mdframed}

Note that you can import multiple modules in a single \texttt{import} statement.

\subsection{Exporting Names}

You can also export names in your module so that they are visible to other modules with \texttt{export} form as follows:

\begin{mdframed}[style=example]
\begin{verbatim}
  bind A 1
  also B 2
  also C 3
  then export A B C @.
\end{verbatim}
\end{mdframed}

The Towel compiler will automatically generate a \texttt{'.e'} file for each compiled \texttt{'.t'} file for the purposes of name exportation.\footnote{Very much like the C header files, but less powerful.} An empty one will be generated, even if there are no names exported in the source file.

\section{Wait, What about Garbage Collection?}

Towel definitely collects garbage for you!

In current implementation of the TVM, when a value is popped out from a stack, the value gets GC'ed immediately.\footnote{Mayn thanks to OCaml!} When a stack is popped from the data stack stack, all the values on the popped stack are GC'ed immediately. So basically, Towel gets garbage collection for free because of its stack-based computation model.

Oh, and of course, extensions have to manage their own memory. Because they are out of the TVM's touch.

\section{Switches}
\label{sec:switches}

Towel provides some switches to change the default behavior of the compiler:
\begin{itemize}
\item \texttt{hungry}
\item \texttt{share-stack}
\item \texttt{optimize-seq}, on by default
\end{itemize}

If you want to turn on/off these switches, type in the switch names on first line, leave an empty line next to it, then go on with your code, like this:
\begin{mdframed}[style=example]
\begin{verbatim}
  I'm so hungry! Also please share-stack.

  bind Something-new (1 2 -)
  then Something-new
\end{verbatim}
\end{mdframed}

If \texttt{hungry} is turned on, \texttt{if} forms will be compiled to their respective hungry versions, which consume the TOS they test against when the test finishes, i.e. immediately after falling in particular branches or after failing to fall in any of the branches. This is useful when you want to be thrifty about stack spaces.

\begin{mdframed}[style=hint]
  You can also achieve this with \texttt{hungry} turned off by calling \mstd{!!pop} explicitly.
\end{mdframed}

When \texttt{share-stack} is on, every function (including sequence of course) uses the same stack, you get more classic stack-based language programming experience\footnote{And probably faster execution, because the context switching is done a lot faster without data stacks pushing and popping.} out of this switch, but you may want to make sure functions don't leave extra elements on the stack, so you'd better turn on \texttt{hungry} switch along with this.

If you turn on \texttt{optimize-seq} switch, when you create a sequence as the body of a function, \texttt{if} form, or \texttt{then} clause of \texttt{bind-then} forms, this sequence is optimized to disappear, leaving the body of it as the body of the form.

\begin{mdframed}[style=detail]
  The reason that I don't make them arguments to the compiler, is because I believe these kinds of configuration is a part of the code. If you were to make the arguments to the compiler, users with different compiler settings while compiling will have different bytecode, thus different result.
\end{mdframed}

\chapter{The Standard Library}

\section{Naming Conventions}

In towel, we encourage Lisp-like naming styles. But since only upper-cased characters are allowed to appear as the first alphabet character in a name, we normally prepend a punctuation to it.

\begin{itemize}
\item For routines, we would normally prepend an exclamation mark to
  such routines. For example, \mstd{!print}. For routines with serious side-effects, we prepend two.

\item For functions that operate on enumerables, we prepend \texttt{\#}.

\item For functional functions, we prepend a slash (half of the $\lambda$ character). For example, we have in the standard library \mstd{/foldl}, \mstd{/map}.

\item For predicates (something that returns \texttt{true} or \texttt{false}), we prepend a question mark.

\item For arithmetic functions, we don't prepend anything.

\item For arguments, we usually prepend a \texttt{\mtilde} for the sake of simplicity.
\end{itemize}

\section{Module \texttt{Std}}

Module \texttt{Std} is the very basic standard library of the Towel programming language. It consists of functions of multiple domains.

\subsection{Arithmetic Functions}

This category contains the following functions:
\begin{itemize}
\item \arithstd{+}

add \marg1 and \marg2
\item \arithstd{-}

\marg1 minus \marg2
\item \arithstd{*}

multiply \marg1 and \marg2
\item \arithstd{/}

divide \marg1 by \marg2
\item \arithstd{**}

\marg1 to the power of \marg2
\item \arithstd{\%}

\marg1 modulo \marg2
\end{itemize}

\begin{mdframed}[style=hint]
  This leftarrow thing is just to highlight the arguments that should be applied to the function, and implies the stack-based nature of Towel, i.e. the order the functions acquire their arguments.

  For example, \arithstd{-} means that \mstd{-} grabs \marg2 first, then \marg1, but still calculates $\marg1 - \marg2$.
\end{mdframed}

It also contains various functions for comparison purposes:

\begin{itemize}
\item \arithstd{=}

tests if \marg1 equals to \marg2
\item \arithstd{>}

tests if \marg1 is the greater than \marg2
\item \arithstd{>=}

tests if \marg1 is the greater than \marg2
\item \arithstd{<}

tests if \marg1 is the less than \marg2
\item \arithstd{<=}

tests if \marg1 is the less than or equal to \marg2
\item \arithstd{<>}

tests if \marg1 is not equal to \marg2
\end{itemize}

Let's not forget about bitwise arithmetic functions:

\begin{itemize}
\item \arithstd{:and}

bitwise and between \marg1 and \marg2
\item \arithstd{:or}

bitwise or between \marg1 and \marg2
\item \arithstd{:not}

bitwise not \marg1
\item \arithstd{:xor}

bitwise xor between \marg1 and \marg2
\item \arithstd{:shl}

bitwise shift left \marg1 for \marg2 bits
\item \arithstd{:shr}

bitwise shift right \marg1 for \marg2 bits
\item \arithstd{:lshr}

bitwise logical shift right \marg1 for \marg2 bits
\end{itemize}

\begin{mdframed}[style=hint]
  Arithmetic functions only work for numbers.

  The equality and non-equality function works for most of the types (including type \texttt{Type}).
  The comparison functions only work for numbers because they are implemented using the substraction function.

  Bitwise functions only work for fixed integer and unsigned fixed integer.
\end{mdframed}

\begin{mdframed}[style=hint]
  The above functions must be applied to values of the same type. Otherwise the TVM will throw an error and exit.
\end{mdframed}

\subsection{Conversion Functions}

Because Towel is a strong-typed language, we provide you some conversion functions to cast the values around.

\begin{mdframed}[style=warning]
  Think before you use these functions.
\end{mdframed}

\begin{itemize}
\item \marg1 \mla \mstd{\textasciitilde fint}

converts \marg1 of unsigned fixed integers, floats, big integers, or strings into a fixed integer
\item \marg1 \mla \mstd{\textasciitilde ufint}

converts \marg1 of unsigned fixed integers, floats, big integers, or strings into an unsigned fixed integer
\item \marg1 \mla \mstd{\textasciitilde int}

converts \marg1 of unsigned fixed integers, floats, big integers, or strings into a big integer
\item \marg1 \mla \mstd{\textasciitilde float}

converts \marg1 of unsigned fixed integers, floats, big integers, or strings into float number
\item \marg1 \mla \mstd{\textasciitilde str}

stringifies \marg1 of any possible value to a string
\end{itemize}

\subsection{Reflection Function}

Use \texttt{\string^?} if you want to know the type of a value at runtime. The return value of this function can be tested equality against other type values.

\subsection{Routines}

\begin{itemize}
\item \marg{x} \mla \mstd{!print}

prints \marg{x}
\item \marg{x} \mla \mstd{!println}

prints \marg{x} plus a newline character
\item \mstd{!read}

reads in a string from standard input and push it onto the stack
\item \mstd{!!pop}

pop the last element on current stack
\item \mstd{!!dup}

duplicate the last element on current stack
\item \texttt{...} \mla \marg{n} \mla \mstd{!!pack}

pack \marg{n} elements on current stack into a tuple
\item \marg1 \mla \mstd{!!unpack}

unpack \marg1 into N elements and push them onto current stack
\item \marg{fun} \mla \mstd{!invoke}

invoke \marg{fun} as a function when you don't know the arity of it
\end{itemize}

\begin{mdframed}[style=hint]
  Because of the low-levelness of \mstd{!!pack} and \mstd{!!unpack}, they do not accept argument the same way other functions do, but directly from current stack. So you cannot create curried functions out of them.
\end{mdframed}

\subsection{Phony}

Use \mstd{\$\$} to push a phony onto current stack.

\begin{mdframed}[style=warning]
  Do not try to \mstd{!!pop} a phony, it will result in an \texttt{PhonyEmptyStack} error.
\end{mdframed}

\subsection{Working with Enumerables}


\subsubsection{Functions that Works with Both Lists and Tuples}

Only one exists for now: \marg{x} \mla \mstd{?\#}, \marg{x} emptiness test.

\subsubsection{List-only Functions}

\begin{itemize}
\item \marg{l} \mla \mstd{\#hd}

get the head of \marg{l}
\item \marg{l} \mla \mstd{\#tl}

get the tail of \marg{l}
\item \marg{e} \mla \marg{l} \mla \mstd{\#cons}

cons \marg{e} and \marg{l} into a new list
\item \marg{l} \mla \mstd{\#rev}

reverse \marg{l}
\item \marg{l1} \mla \marg{l2} \mla \mstd{\#concat}

concatenate \marg{l1} and \marg{l2}
\item \marg{l} \mla \mstd{\#len}

get the length of \marg{l}
\end{itemize}

\begin{mdframed}[style=hint]
  Remember everything in Towel is immutable.
\end{mdframed}

\subsubsection{Tuple-only Functions}

\begin{itemize}
\item \marg{n} \mla \marg{t} \mla \mstd{\#tn}

get the \marg{n}-th element of \marg{t}
\item \marg{t} \mla \mstd{\#t1}

get the first element of \marg{t}
\item \marg{t} \mla \mstd{\#t2}

get the second element of \marg{t}
\item \marg{t} \mla \mstd{\#t3}

get the third element of \marg{t}
\end{itemize}

\subsection{Functional Functions}

\begin{itemize}
\item \marg{x} \mla \mstd{/id}

the identity function, i.e. it returns \marg{x}
\item \marg{init} \mla \marg{list} \mla \marg{fun} \mla \mstd{/foldl}

folds the  list\marg{list} from left to right on function \marg{fun}, with the initial value being \marg{init}
\item \marg{init} \mla \marg{list} \mla \marg{fun} \mla \mstd{/foldr}

same as \mstd{/foldl}, except that this walks the list from right to left and is not tail recursive function
\item \marg{list} \mla \marg{fun} \mla \mstd{/map}

maps function denoted by \marg{fun} onto \marg{list}
\item \marg{list} \mla \texttt{?pred} \mla \mstd{/filter}

for each element \marg{x} in \marg{list}, discards \marg{x} when \texttt{\marg{x} ?pred} turns out to be \texttt{true}
\item \marg1 \mla \marg2 \mla \marg{fun} \mla \mstd{/flip}

flips the arguments of a binary function \marg{fun}, i.e. \texttt{\marg2 \marg1 \marg{fun}}
\item \marg{args} \mla \marg{fun} \mla \mstd{/apply}

apply the elements in \marg{args} as arguments to \marg{fun}
\end{itemize}

\begin{mdframed}[style=hint]
  You may want to use backquotes when using these functions, for example,

\begin{verbatim}
  ([1 2 3 4 5] !println /map)
\end{verbatim}

prints out
\begin{verbatim}
  [1 2 3 4 5]
\end{verbatim}

rather than
\begin{verbatim}
  1
  2
  3
  4
  5
\end{verbatim}

To do this correctly, you should backquote \texttt{!println} like this

\begin{verbatim}
  ([1 2 3 4 5] !println` /map)
\end{verbatim}

This backquote prevents \texttt{!println} from executing, leaving it be as a function value so that it can be passed to \texttt{/map}.
\end{mdframed}

\section{Module \texttt{Random}}

This module exploits the extension mechanism provided by current implementation of the TVM to easily invoke functions in OCaml. See the virtual machine manual for more details.

The provided functions are
\begin{itemize}
\item \marg{s} \mla \texttt{\mtilde ~seed\textbackslash Random}

change the seed used in random number generation to \marg{s}
\item \texttt{\mtilde ~useed\textbackslash Random}

change the seed according to \texttt{/dev/urandom} on *nix systems, or system parameters if \texttt{/dev/urandom} is not available
\item \texttt{\mtilde ~\mtilde ~\textbackslash Random}

generates a random floating point number within the range of $[0.0, 1.0]$.
\end{itemize}


\chapter{Weaving a Towel Program}

The compiler for the Towel programming language is codenamed \texttt{weave}, you can find it in \texttt{build/src/compiler} after successfully compiling the whole project with
\begin{mdframed}[style=example]
\begin{verbatim}
  ./waf configure build --tvm --compiler --native
\end{verbatim}

\textit{*This will build both the compiler and the TVM. The built binaries are both standalone.}
\end{mdframed}

To compile a source file \texttt{foo.t}, and want the compiled output to be \texttt{bar.w}, use
\begin{verbatim}
        path-to-weave foo.t -o bar.w
\end{verbatim}

If you want to see the human-readable bytecode file, apply -t to \texttt{weave}, for example
\begin{verbatim}
        path-to-weave foo.t -o bar.l -t
\end{verbatim}

If you want to read the unassembled compiled file (human-readable) for debugging purposes, apply -r to \texttt{weave} like this
\begin{verbatim}
        path-to-weave foo.t -o bar.o -r
\end{verbatim}

If you have a human-readable bytecode file, and want to compile into VM-readable bytecode file, apply -b to \texttt{weave}, e.g.
\begin{verbatim}
        path-to-weave foo.l -o bar.w -b
\end{verbatim}

\begin{mdframed}[style=hint]
  Recommended extension for Towel source file is \texttt{.t}, because it's the first letter of the word \textit{towel}.

  Recommended extension for raw unassembled compiled file is \texttt{.o}, which means original Towel.

  Recommended extension for Towel bytecode file is \texttt{.w}, meaning woven Towel. It's also the third letter of \textit{towel}!\footnote{I love wordplay so much!}.

  By default, files that contains the exported names of the module have the extension of \texttt{.e}, meaning exportation.

  And finally recommended extension for human-readable bytecode file is \texttt{.l}.
\end{mdframed}

\chapter{Examples}
\label{chap:examples}

The following examples run under the default switch configuration.

\section{Concrete Examples}

\subsection{Greatest Common Divisor}
\begin{mdframed}[style=example]
\begin{verbatim}
  import 'std' @

  bind GCD fun` A B,
    (A B - if=0 A (5),
       if>0 (1) (!!pop A B - B GCD@ (2)),
       if<0 (!!pop (3) A B A - GCD@),
         ~idle (4))
  then (42 24 GCD !println)
\end{verbatim}
\end{mdframed}

\begin{enumerate}
\item See how \texttt{if} forms are chained here!
\item Note that we are tail recursing the \texttt{GCD} function here.
\item As is mentioned in previous chapters, when doing tail recursive calls, you really want to be careful about your stack usage to avoid stack leakage.
\item Remember an \texttt{if} form have two branches, and both of them cannot be omitted. So we put \sout{Eric Idle} \mstd{\mtilde ~idle} here to denote that we don't want to do anything here, just a placeholder.
\item The exit of the recursive function, so we'll directly put \texttt{A} here, without popping the result of \texttt{A B -}. Because this stack will be destroyed and all the values on it GC'ed, after it returns \texttt{A}.
\end{enumerate}

\subsection{Fibonacci Numbers}
\begin{mdframed}[style=example]
\begin{verbatim}
  bind Fib fun` A B N,
    (N if=0 A,
         (A B + A 1 N - Fib@))
  then (1 1 10 Fib)
\end{verbatim}
\end{mdframed}
Trivial.

\section{And Now for Something Completely Different...}

\subsection{Quicksort}
\begin{mdframed}[style=example]
\begin{verbatim}
  import 'std' @ (1)

  bind #quicksort (2) ,\ (3) L,
    (L ?#empty ift (!!pop (4) []), (!!pop
      bind ~h (L #hd)
      also ~t (L #tl)
      then (~t (~h >) (5) /filter #quicksort
            [~h]
            ~t (~h <=) /filter #quicksort
        #concat #concat (6))))
  then ([5 4 3 2 1] #quicksort !println)
\end{verbatim}
\end{mdframed}

\begin{enumerate}
\item Implicitly import module \texttt{Std} so that we can use the names bound in it without referencing to the module name.
\item Remember our naming conventions? Quicksort works on lists, so we prepend a \texttt{\#} to it.
\item It's a synonym for \texttt{fun`}.
\item Use \mstd{!!pop} to be thrifty about memory spaces.
\item Utilizing non-shared sequence to create partial applied function.
\item We have three lists on stack, so it takes two \mstd{\#concat}s to merge them all into one list.
\end{enumerate}

\subsection{Backquotes}
\label{ssec:backquote}
\begin{mdframed}[style=example]
\begin{verbatim}
  import 'std' \

  bind Sum ,\ ~ls,
    (0 ~ls +\Std` (1) /foldl\Std)
  then export Sum @
\end{verbatim}
\end{mdframed}

\begin{enumerate}
\item Be sure to quote this plus function (actually, the name) so that \mstd{/foldl} can use the addition function, rather than the value the function evaluated, and of course, in this case, you can never evaluate \mstd{+} with a number and a list.
\end{enumerate}

\subsection{(Fake) Macros}
\label{ssec:macro}
\begin{mdframed}[style=example]
\begin{verbatim}
  bind Macro1 (@ if~0 +, -)`
  also Macro2 {if~0 +, -}
  then bind Fun fun` A B,
         (A B Macro1)
       then (1 2 Fun).
\end{verbatim}
\end{mdframed}

A quick explanation: \texttt{(@ if\textasciitilde 0 +, -)} is bound to name \texttt{Macro1} as we want, which is essentially an anonymous function that tests whether the TOS of the caller's stack (because it's a shared sequence) is zero. The overall effect of this piece of code is like we have done a code replacement (at runtime).

\texttt{Macro2} is a short-hand version of \texttt{Macro1}.

\subsection{Object-oriented Programming}

\subsubsection{Not Even Close}

\begin{mdframed}[style=example]
\begin{verbatim}
  bind Class fun` ~init-value,
    bind ~data ~init-value
    then bind Accessor fun`, ~data (1)
         then [\ (2) Accessor` (3) ] (4)
  then bind Instance1-methods (41 Class)
       also Instance2-methods (42 Class)
       then bind Instance1-accessor (Instance1-methods #t1 (5))`
            also Instance2-accessor (Instance2-methods #t1)`
            then (Instance1-accessor !println
                  Instance2-accessor !println)
\end{verbatim}
\end{mdframed}

\begin{enumerate}
\item \marg{data} is captured by the \texttt{Accessor} function, which will be returned by the \texttt{Class} \textbf{function} (ha!), and you get all the public methods from the return value of this \texttt{Class} function as a tuple.
\item Maybe I should remind you that we use \texttt{[\textbackslash ~]} to denote a tuple
\item Don't forget to backquote you methods!
\item You can replace this \texttt{[\textbackslash Accessor`]} with \texttt{(1 !!pack)}.
\item Get the accessor function from the first slot of the tuple.
\end{enumerate}

The above code snippet will produce the output
\begin{verbatim}
  41
  42
\end{verbatim}

which is exactly what we would be expecting.

\subsubsection{A More Advanced Example}

\begin{mdframed}[style=example]
\begin{verbatim}
  import 'std' @

  bind >>send !invoke`

  also Shape ,\ ~type, (7)
    bind __type ~type
    also Type fun`, #t1 "dirty hack to make this work with >>send"
    also Area #t2`
    then [\__type [\Type` Area`]]

  then bind __meta-Shape ('' Shape)
       also :type (__meta-Shape #t2 #t1) (1)
       also :area (__meta-Shape #t2 #t2)

       also Circle ,\ Radius,
         bind __radius Radius (2)
         also ~super ('Circle' Shape) (3)

         then bind Type (~super #t1)
              also Area ,\, (__radius !!dup 3.14159 * *) (4)

              then [\Type` Area`] (5)

        also Rectangle ,\ Width Height,
          bind __width Width
          also __height Height

          also ~super ('Rectangle' Shape)

          then bind Type (~super #t1)
               also Area ,\, (__width __height *)
  
               then [\Type` Area`]

        then bind ~my-circle (42 Circle)
             also ~my-rectangle (1 2 Rectangle)
             then (~my-circle :type >>send (6) !println
                   ~my-rectangle :type >>send !println
                   ~my-circle :area >>send !println
                   ~my-rectangle :area >>send !println)
\end{verbatim}
\end{mdframed}

\begin{enumerate}
\item Make a meta object to get all the available messages a Shape object can receive.
\item A private field of Circle objects.
\item The superclass (or super object).
\item Implementing the abstract method!
\item The public available methods.
\item This is really great: we are sending the message \texttt{:type} to the Circle object \texttt{\mtilde ~my-circle}, and hoping the object will respond. \textit{Now we are speaking Japanese!}
\item So in retrospect, it's more like an interface or protocol (with some dirty hacks), rather than an abstract class.
\end{enumerate}

The key idea here is that the interface function returns a tuple of the indexing functions that specifiy the position of each method in classes that agree with this protocol.

For example, \texttt{:area} is actually the \texttt{\#t2} function, and is used to get the first element from a Shape object, which is a tuple with the second element being the function that does the calculation for area.

It's a shame that we don't have Lisp macros here, otherwise the syntax will be much simpler here.\footnote{Common LISP actually has a package that does object-oriented programming simulation, which is of course much powerful than what I have shown here.}

\subsection{GUI Programming}

Here in this example, we will show you how to call functions from OCaml using the extension feature of the OCaml Towel Virtual Machine. This part is rather implementation specific. So be sure you are using the OCaml implementation of the Towel Virtual Machine.\footnote{Sure you are now!} For more on this topic, see also the chapter on Extending the Towel Virtual Machine in the Towel Assembly and Virtual Machine manual.

Below is the code listing of the OCaml-side wrapper for some Tk GUI functions. Notice how this wrapper interacts with the TVM via pushing and popping elements from \texttt{dss}, i.e. the data stack stack.

\begin{mdframed}[style=example]
  \begin{minted}{ocaml}
  open Tk;;
  open T;;
  open Ext;;
  open Nstack;;

  let top = ref None;;

  let widgets:(int, Widget.toplevel Widget.widget) Hashtbl.t = Hashtbl.create 512;;

  let tkfail msg = failwith (Printf.sprintf "TK failure: %s.\n" msg);;

  module SimpleTk : TowelExtTemplate =
  struct
    let extcall cn dss = match cn with
        1 -> top := Some(openTk ())
      | 2 -> mainLoop ()
      | 3 -> closeTk ()
      | 4 -> update ()
      | 5 -> let s = appname_get ()
        in dspush dss (OVString(s))
      | 6 -> let s = match (dspop dss) with
            OVString(x) -> x
          | _ -> tkfail "unsupported data type for appname_set"
        in appname_set s
      | _ -> tkfail "unimplemented call number"
  end

  let () = __ext__ := Some(module SimpleTk : TowelExtTemplate);;
  \end{minted}
\end{mdframed}

Then you may want to write a wrapper from Towel-side so that you can call the OCaml wrapper more conveniently.

\begin{mdframed}[style=example]
\begin{verbatim}
  import '.w' \

  bind ^~ ('ext_tk.cmo' !>ext\.w)
  also !>> !>>\.w`

  also >>tk fun`, (1u ^~ !>>)
  also ~~~ fun`, (2u ^~ !>>)
  also <<tk fun`, (3u ^~ !>>)

  also !set-tk-appname fun` ~s, (~s 6u ^~ !>>)

  then export >>tk ~~~ <<tk !set-tk-appname @
\end{verbatim}
\end{mdframed}

The choices of names are purely ideographic. For example, \texttt{>>tk} denotes that you are now entering the Tk world, i.e. the \texttt{openTk} function of OCaml.

With these two wrappers done, you can write a simple program to invoke the wrappers, like this

\begin{mdframed}[style=example]
\begin{verbatim}
  import 'simple-tk' @

  (>>tk
   'Hello, world by the Towel programming language!' !set-tk-appname
   ~~~
   <<tk)
\end{verbatim}
\end{mdframed}

You can read this example like this: first we enter the Tk environment, then set the Tk application name to \texttt{'Hello, blah blah...'}, after that we call the mainloop denoted by three consecutive tildes. When control returns from the mainloop, we now exit Tk environment by flowing from \texttt{tk}. You can of course design the API like this in callback fashion:

\begin{mdframed}[style=example]
\begin{verbatim}
  bind >>with-tk-env ,\ ~fun, (>>tk ~fun ~~~ <<tk)
  then (('Hello world!' !set-tk-appname)` >>with-tk-env)
\end{verbatim}
\end{mdframed}

If you compile the OCaml-side wrapper correctly and run the last but one example, you will get something like this:

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.75]{fig-gui.png}
  \caption{Hello world!}
  \label{fig:gui}
\end{figure}

\part{The Towel Assembly and Virtual Machine Manual}

\chapter{An Overview on the Towel Virtual Machine}

The Towel virtual machine is basically a stack-based state machine that accepts and executes Towel Assembly Language. It reads instructions sequently from instruction buffer and does its computation on stacks. It has the following important parts:
\begin{itemize}
\item execution stack (or the activation record stack): \texttt{ctx\_t list}\footnote{Note that, Towel Virtual Machine does not restricts itself to any single kind of implementation. The use of OCaml type notation here is for convenience and clarity.}
\item data stack stack: \texttt{value\_t dstack\_t dstack\_t}
\item flags record: \texttt{flags\_t}
\item module table: \texttt{(module\_id\_t, module\_t) Hashtbl.t}
\item extension table: \texttt{(module\_id\_t, module TowelExtTemplate) Hashtbl.t}
\end{itemize}

\section{Execution Stack}

Execution stack is where context of function calls are stored. A context of a function call consists the return address of the function call, the module id of the return address is in\footnote{The PC jumps around different instruction arrays of different modules.}, the function value of the function being called.

When a new function call is made, the context of this call is pushed onto the execution stack, followed by the instruction pointer jumping to the start position of the function, and the \texttt{curmod} field being switched to the target module. When the instruction \texttt{ret} is met, the function returns. TVM pops the TOS on execution stack and jumps to the return address stored in this TOS and switch back to the original module according to the \texttt{ctx\_t} value.

\begin{mdframed}[style=detail]
  Execution stack has one element in it initially. This context has no
  meaningful record fields.
\end{mdframed}

\section{Data Stack Stack}

Every function has a stack for itself to do its computation. This avoids stack corruptions along all the function executions. Data stack is essentially an important part of the context of the function call, but it is so important, we would like to operate them manually so that we could be more flexible.

Normally, when a new function call is made, a new data stack is pushed onto the data stack stack. When the function returns, TVM pops the TOS from the TOS of data stack stack (i.e. the return value of this function is the TOS of current function's data stack), pushes it onto the caller's stack (next to the TOS of data stack stack). Then this data stack gets popped, thus the caller's data stack is now the TOS of the data stack stack. TVM now pops and evaluates the TOS of the caller's data stack (this is a vital step) and pushes back the evaluated value.

\begin{mdframed}[style=detail]
  Data stack stack has one element (i.e. a data stack) in it
  initially, whereas the data stack has no elements whatsoever.

  Data stack stack is implemented by module \texttt{Nstack}, which
  provides the type \texttt{'a dstack\_t} (d for dynamic), and a lot
  of dedicated function for accessing the \texttt{dss} field in
  various ways.
\end{mdframed}

\section{Flags}

Flags stores the essential states for the virtual machine to run. For example, \texttt{is\_tail\_recursive\_call} records if the virtual machine is executing a tail recursive function. \texttt{curmod} records the current module whose instructions the PC is pointing at. \texttt{dss} is the data stack stack we talked about above. \texttt{scps} stores all the the names in scope stack (\texttt{scope\_t list}) for dynamic scoping.

\section{Module table}

Any functional Towel source code inevitably references (or, imports) other modules. When an \inst{import} is executing, a \texttt{module\_t} value is created and based on the module name, a UID is allocated for this module for referencing it later. Then the VM uses the UID as the key to store the \texttt{module\_t} value into the module table.

\subsection{Modules}

A module is a compiled Towel source code loaded into TVM, it has the following important fields:
\begin{itemize}
\item \texttt{id} of type \texttt{module\_id\_t}
\item \texttt{insts} of type \texttt{line array}
\item \texttt{exs} of type \texttt{(name\_t, value\_t) Hashtbl.t}
\item \texttt{imports} of type \texttt{(module\_id\_t, module\_id\_t) Hashtbl.t}
\end{itemize}

\texttt{exs} is the exported value table of the module, mapping from a name to a value.

\texttt{imports} is the absolute module id relative to this module. In the Towel compiler, names are resolved by a 2-tuple: the name id in the module and the module id. Because when compiling, the Towel compiler has no information about other modules other than the \texttt{.e} exportation file (like the header files you use in C). So it can only label other modules by IDs relative to itself (itself being zero).

When importing a new module, the module gets a global (absolute) id, all the referencing of this module should be made through this very id. So it's vital that every module maintains a mapping from the relative module id in its instructions to the absolute module id given by TVM. See \ref{fig:imports} for an intuitive illustration.

\begin{figure}[h]
\psscalebox{1 1} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-6.8)(12.02,6.8)
\psframe[linecolor=black, linewidth=0.04, dimen=outer](5.62,6.8)(0.42,-2.0)
\rput[bl](1.22,4.4){\texttt{push-name 0u 1u}}
\rput[bl](1.22,4.0){\texttt{push-name 0u 2u}}
\rput[bl](1.22,3.6){\texttt{push-name 0u 0u}}
\rput[bl](1.22,5.2){\texttt{import 'std' 1u}}
\rput[bl](1.22,4.8){\texttt{import 'random' 2u}}
\rput[bl](1.22,5.6){\texttt{...}}
\rput[bl](1.22,3.2){\texttt{...}}
\psframe[linecolor=blue, linewidth=0.04, dimen=outer](12.02,6.8)(7.62,1.2)
\rput[bl](2.02,-2.4){Your module}
\rput[bl](8.82,0.8){Module Std}
\rput[bl](8.02,5.6){\texttt{...}}
\rput[bl](8.02,5.2){\texttt{bind 0u}}
\rput[bl](8.02,4.8){\texttt{...}}
\rput[bl](8.82,0.4){\texttt{id = 5u}}
\rput[bl](0.82,6.4){\texttt{id = 1u}}
\psframe[linecolor=green, linewidth=0.04, dimen=outer](12.02,-0.4)(7.62,-6.0)
\rput[bl](8.02,-3.6){\texttt{...}}
\rput[bl](8.02,-4.0){\texttt{bind 0u}}
\rput[bl](8.02,-4.4){\texttt{...}}
\rput[bl](8.82,-6.4){Module Random}
\rput[bl](8.82,-6.8){\texttt{id = 3u}}
\psframe[linecolor=black, linewidth=0.04, dimen=outer](5.22,6.0)(0.82,2.8)
\psframe[linecolor=black, linewidth=0.04, dimen=outer](5.22,1.2)(0.82,-1.2)
\rput[bl](1.22,0.8){\texttt{1u -> 5u}}
\rput[bl](1.22,0.4){\texttt{2u -> 3u}}
\rput[bl](2.42,2.4){\texttt{insts}}
\rput[bl](2.42,-1.6){\texttt{imports}}
\psline[linecolor=blue, linewidth=0.04](4.02,4.4)(4.42,4.4)(4.42,1.6)(1.22,1.6)(0.82,1.6)(0.82,0.8)(1.22,0.8)(1.22,0.8)
\psline[linecolor=blue, linewidth=0.04](2.82,0.8)(7.22,0.8)(7.22,5.2)(7.62,5.2)(7.62,5.2)
\psline[linecolor=green, linewidth=0.04](4.02,4.0)(4.82,4.0)(4.82,2.0)(0.02,2.0)(0.02,0.4)(1.22,0.4)(1.22,0.4)
\psline[linecolor=green, linewidth=0.04](2.82,0.4)(7.22,0.4)(7.22,-4.0)(7.62,-4.0)(7.62,-4.0)
\end{pspicture}
}
\label{fig:imports}
\end{figure}

\section{Extension table}

Essentially the same thing as the module table, except that it stores extensions (of type \texttt{module Ext.TowelExtTemplate}) via \inst{load-ext}.

\renewcommand{\marg}[1]{\texttt{IARG\_#1}}
\newcommand{\sarg}[1]{\texttt{SARG\_#1}}
\newcommand{\parg}[1]{\texttt{PARG\_#1}}

\chapter{Towel Assembly Language and Its Instructions}

\section{Overview}

Towel Assembly Language has the same (or less) lexical elements as the Towel programming language. And it's grammar is very simple: each line of a Towel Assembly program has no or multiple labels, an instruction, and some arguments or no argument at all according to the instruction's arity.

After assembling, labels preceding a line are eliminated, and labels as arguments are replaced with their absolute position (i.e. the line number relative to the starting of the TAL source file, of the line where they appear as line labels).

Essentially, this assembly language is considered to be the intermediate representation of compiled Towel programs. And the TVM is a facility to execute IR directly. We can always compile IR further to, for example, native code or other virtual machines like JVM.

\subsection{Data Types}

\begin{itemize}
\item \texttt{VString}: a string surrounded by single quote
\item \texttt{VAtom}: an unsigned 64bit integer followed by an ``a''
\item \texttt{VUFixedInt}: an unsigned 64bit integer followed by a ``u''
\item \texttt{VFixedInt}: a signed 64bit integer
\item \texttt{VInt}: an integer of arbitrary precision followed by an ``l''
\item \texttt{VFloat}: a float number
\end{itemize}

\section{Scope-related Instructions}

\begin{mdframed}[style=hint]
  In the upcoming sections, we use the following convention to denote arguments of the instructions:

  \begin{itemize}
  \item \marg{SOME} means this argument is a part of an instruction.
  \item \sarg{SOME} means this argument is fetched from the data stack, and it will be put back potentially modified.

Stack argument that appears first is popped first, and so forth.

Also the term TOS and \sarg{SOME} are often interchangeable if there exists only one stack argument.
  \item \parg{SOME} is the same as \sarg{SOME}, except that \parg{SOME} is popped out from the stack forever.
  \end{itemize}
\end{mdframed}

\subsection{\texttt{0x01} \inst{push-scope}}

Pushes a new scope onto the scope stack.

\subsection{\texttt{0x02} \inst{pop-scope}}

Pops the TOS of the scope stack.

\subsection{\texttt{0x03} \inst{share-scope}}

Does absolutely nothing. Just a place-holder to indicate that this new context shares the same scope with its parent.

\subsection{\texttt{0x04} \inst{bind} \marg{UID}}

The argument \marg{UID} denotes the ID of the name that the TVM will bind TOS to. Then TVM does it in current scope.

\subsection{\texttt{0x05} \inst{fun-arg} \marg{UID}}

\inst{fun-arg} is a compound instruction\footnote{A compound instruction is an instruction with multiple side-effects.}. It steals (pops) from the caller's data stack\footnote{The second top stack of DSS, or the top stack of DSS if it's a tail recursive call.} and binds a reference to the value to the name indicated by the \marg{UID} in the clone of the \texttt{closure} table of the function.

\begin{mdframed}[style=detail]
  If the stack turns out to be empty, this instruction saves the
  name-value pairs already bound (arguments stole by previous
  \inst{fun-arg}s) in the copy of the closure of the current function
  (\texttt{curfun} of the TOS of ctxs), marks the function as partial
  and returns that function.

  Also if the stack is empty because the TOS is a phony, it removes the
  phony.
\end{mdframed}

\begin{mdframed}[style=hint]
  Why copy the \texttt{closure} table? Think about the execution of a recursive function,

\begin{verbatim}
  {ctx_current with arg1 = 5; arg2 = ?}
  {ctx1 with arg1 = 3; arg2 = 4}
  {ctx0 with arg1 = 1; arg2 = 2}
\end{verbatim}

If arguments were put into the table directly, applying arg2 with, for example, 10, in \texttt{ctx\_current} will result in \texttt{ctx1.arg2 <- 10} and \texttt{ctx0.arg2 <- 10}. In other words, you just corrupted the activation records.

So you may ask, why not putting the arguments directly on stack, and bind the given \marg{UID} to the index of that argument, just like what \inst{bind} does? The reason is that, if this is the case, it would be almost impossible to implement automatic currying. Because when returning the partial applied function, the stack that saves the arguments will be destroyed, and all your arguments will be lost.
\end{mdframed}

Sorry for such a complicated (and probably the only complicated) instruction.

\section{Stack-related Instructions}

\subsection{\texttt{0x10} \inst{push-fun} \marg{START}}

Makes a new function value and pushes it onto the stack without evaluating it. It takes \marg{START} as the start position of the function to be created. The module id of the function is considered to be \texttt{curmod.id}.

\subsection{\texttt{0x11} \inst{push-lnil} and \texttt{0x12} \inst{push-tnil}}

Makes a new list or tuple on top of the current data stack. TVM also puts the pointer of its content onto \texttt{flags.list\_make\_stack} to keep track where to put new values (such as values from \inst{push-lit}, \inst{push-lnil} or \inst{push-tnil}), when TVM reaches \inst{end-list} or \inst{end-tuple}, the ref on top of \texttt{flags.list\_make\_stack} is popped.

\begin{mdframed}[style=detail]
  Only selected instructions have effect on these list pointers:
  \begin{itemize}
  \item \inst{eval-and-push}
  \item \inst{push-lit}
  \item \inst{push-phony}
  \item \inst{push-name}
  \item \inst{push-fun}
  \item \inst{dup}
  \item Instructions that return some value.
  \end{itemize}
\end{mdframed}

\subsection{\texttt{0x13} \inst{end-list} and \texttt{0x14} \inst{end-tuple}}

Ends current list or tuple construction.

\subsection{\texttt{0x15} \inst{push-lit} \marg{LIT}}

Pushes a literal \marg{LIT} onto the stack or the list pointer on top of \texttt{flags.list\_make\_stack}.

\subsection{\texttt{0x16} \inst{push-name} \marg{NID} \marg{MID}}

Finds the value bound to the name whose ID is \marg{NID}, in the module with the module ID being \marg{MID}, then pushes it onto the stack.

\subsection{\texttt{0x17} \inst{eval-and-push} \marg{NID} \marg{MID}}

Takes two arguments as the description of a name (same as \inst{push-name}), finds the value it is bound to. If the value is a function, then evaluates the function.

\subsection{\texttt{0x18} \inst{pop} \parg{POPPED}}

Pops the TOS of current data stack. In other words, it gets an argument from the stack, then does absolutely nothing.

\subsection{\texttt{0x19} \inst{dup} \sarg{SOME}}

Duplicates the TOS of current data stack. In other words, it gets an argument from the stack, then puts back two.

\subsection{\texttt{0x1a} \inst{reverse} \parg{N} \sarg{1} \sarg{2} ... \sarg{N} (deprecated)}

Takes an argument from the stack, then reverses the \parg{N}-top most elements.

\subsection{\texttt{0x1b} \inst{unpack} \parg{E}}

Assumes the TOS is a list or tuple, then unpacks it onto the stack.

\begin{mdframed}[style=example]
\begin{verbatim}
  dsck: [ ... | [1 2 3]]
  after unpack: [ ... | 1 | 2 | 3]
\end{verbatim}
\end{mdframed}
\subsection{\texttt{0x1c} \inst{pack} \parg{N} \parg{1} \parg{2} ... \parg{3}}

Takes one integer \parg{N} from the stack to pack \parg{N} items on the stack into a tuple.

\begin{mdframed}[style=example]
\begin{verbatim}
  dsck: [ ... | 1 | 2 | 3 | 3]
  after pack: [ ... | [1 2 3]]
\end{verbatim}
\end{mdframed}

\begin{mdframed}[style=hint]
  If there were insufficient number of stack items, TVM throws an
  exception and terminates.
\end{mdframed}

\subsection{\texttt{0x1d} \inst{push-phony}}

Pushes a phony onto the stack that fakes an empty stack. That is to say, whenever TVM encounters a phony, it regards the stack as being empty.

\section{Function-related Instructions}

\subsection{\texttt{0x20} \inst{push-stack}}

Pushes a new data stack onto the data stack stack.

\subsection{\texttt{0x21} \inst{share-stack}}

Same as \inst{share-scope}.

\subsection{\texttt{0x22} \inst{pop-stack}}

Pops the current data stack.

\subsection{\texttt{0x23} \inst{eval-tail} \marg{NID} \marg{MID}}

Finds the function the two arguments references to, then calls it in a tail recursive manner.

\subsection{\texttt{0x24} \inst{ret} \sarg{RET\_VAL}}

Take care of the return value of the function. Pops the execution stack. And jumps to the return address.

\subsection{\texttt{0x25} \inst{shared-ret}}

Just sets the instruction pointer back to where this shared sequence gets called. No return value copied whatsoever (because there isn't any).

\subsection{\texttt{0x26} \inst{closure} \marg{NID} \marg{MID} \sarg{FUN}}

Assumes \sarg{FUN} is a function, takes two argument to describe the name \sarg{FUN} should capture.

\begin{mdframed}[style=detail]
  Because you only need to capture names from self-module, so \marg{MID} is often left being zero\footnote{The self-module ID, i.e. the ID modules reference themselves to.} when compiling.
\end{mdframed}

\subsection{\texttt{0xf2} \inst{install} \sarg{FUN}}

Install the captured names of \sarg{FUN} into current scope so that users can reference them.

\subsection{\texttt{0x27} \inst{invoke} \parg{FUN}}

Assumes TOS is a function, then invokes it. \parg{FUN} is popped before evaluating it.

\subsection{\texttt{0x28} \inst{call} \marg{START}}

Records $PC + 1$ as the return address, then jumps to \marg{START}.

\begin{mdframed}[style=hint]
  This instruction only jumps within the same module.
\end{mdframed}

\section{Conditional Branching Instructions}

\subsection{\texttt{0x30} \inst{jump} \marg{POS}}

Unconditionally jumps to \marg{POS}.

\subsection{\inst{j*} \marg{POS} \sarg{X}}

Tests the TOS with specific predicates. If the result is true, TVM jumps to \marg{POS}, otherwise, TVM executes the next instruction.

\inst{j*} instruction family consists of the following instructions:
\begin{itemize}
\item \texttt{0x32} \inst{jgz}: \sarg{X} is greater than zero,

\texttt{0x31} \inst{jgez}: \sarg{X} is greater than or equal to zero

\item \texttt{0x34} \inst{jlz}: \sarg{X} is less than zero,

\texttt{0x33} \inst{jlez}: \sarg{X} is less than or equal to zero

\item \texttt{0x35} \inst{jez}: \sarg{X} is equal to zero,

\texttt{0x36} \inst{jnez}: \sarg{X} is not equal to zero

\item \texttt{0x37} \inst{jt}: \sarg{X} is \texttt{true},

\texttt{0x38} \inst{jf}: \sarg{X} is \texttt{false}
\end{itemize}

\subsection{\inst{hj*} \marg{POS} \parg{X}}

Hungry versions of \inst{j*} instruction family, which consume the TOS they test against. Their \texttt{opcode}s are the ones of their non-hungry counterpart plus \texttt{0x10}. For example, the \texttt{opcode} of \texttt{jgz} is \texttt{0x42}.

\subsection{\texttt{0x39} \inst{je} \marg{POS}, \texttt{0x3a} \inst{jne} \marg{POS}}

Both of them test if the data stack is empty. \inst{je} jumps to \marg{POS} if it is empty, whereas \inst{jne} jumps only when the stack is non-empty.

\begin{mdframed}[style=detail]
  If \inst{je} is tested against a phony, it pops it before branching.
\end{mdframed}

\section{Arithmetic Instructions}

\subsection{\texttt{0x50} \inst{add}, \texttt{0x51} \inst{sub}, \texttt{0x52} \inst{mul}, \texttt{0x53} \inst{div}, \texttt{0x54} \inst{pow}}

Takes two arguments \parg{1} and \parg{2} from stack. Does arithmetic operations with \parg{1} and \parg{2}, and pushes \texttt{\parg{2} op \parg{1}}. These instructions work for all the number types\footnote{Atoms are not numbers.}.

\subsection{\texttt{0x55} \inst{mod} \parg{1} \parg{2}}

Does modulo operation between integer types.

\subsection{\texttt{0x56} \inst{equ} \parg{1} \parg{2}}

Does equality test on \parg{1} \parg{2}, and puts back \texttt{true} or \texttt{false} atoms.

\begin{mdframed}[style=hint]
  If two different types are tested against each other, TVM exits.
\end{mdframed}

\subsection{Bitwise Instructions}

Fixed integers, unsigned fixed integers, and big integers are supported by the following bitwise arithmetic operations:
\begin{itemize}
\item Bitwise and, \texttt{0x57} \inst{and} \parg{1} \parg{2}
\item Bitwise or, \texttt{0x58} \inst{or} \parg{1} \parg{2}
\item Bitwise xor, \texttt{0x59} \inst{xor} \parg{1} \parg{2}
\item Bitwise not, \texttt{0x5a} \inst{not} \parg{1}
\item Bitwise shift left, \texttt{0x5b} \inst{shl} \parg{X} \parg{N}
\item Bitwise shift right, \texttt{0x5c} \inst{shr} \parg{X} \parg{N}
\item Bitwise logical shift right, \texttt{0x5d} \inst{lshr} \parg{X} \parg{N}
\end{itemize}

Note that \inst{not}, \inst{and} and \inst{or} also work on the \texttt{true} and \texttt{false} atoms.

\subsection{Conversion Instructions}

These instructions allow one type of TOS to convert into value of other types. They are of the following form:
\begin{itemize}
\item \texttt{0x62} \inst{to-fint} \parg{X}
\item \texttt{0x63} \inst{to-ufint} \parg{X}
\item \texttt{0x64} \inst{to-int} \parg{X}
\item \texttt{0x65} \inst{to-float} \parg{X}
\item \texttt{0x66} \inst{to-str} \parg{X}
\end{itemize}

\section{Instructions for Enumerables}

\subsection{\texttt{0x5e} \inst{car} \parg{XS}}

Does CAR operation on linked lists. It takes a list from the stack, puts back the head of the list.

\subsection{\texttt{0x5f} \inst{cdr} \parg{XS}}

Same as \inst{car}, except that it puts back the rest of the list.

\subsection{\texttt{0x60} \inst{cons} \parg{XS} \parg{X}}

Does CONS operation on linked lists. It constructs a new list and then puts it back onto the stack.

\begin{mdframed}[style=hint]
  If it encounters a tuple, TVM exits.
\end{mdframed}

\subsection{\texttt{0x61} \inst{list-empty} \parg{XS}}

Tests if the TOS is an empty \textbf{list or tuple}. It puts back whether \texttt{true} or \texttt{false}, depending on the emptiness of the list or tuple.

\subsection{\texttt{0xf3} \inst{tuple-at} \parg{N} \parg{XS}}

Pushes back the \parg{N}-th element of \parg{XS}.

\section{I/O Instructions}

\subsection{\texttt{0x67} \inst{show} \parg{X}}

Prints the TOS to standard output.

\subsection{\texttt{0x68} \inst{read}}

Reads a string from standard input and store that string on the stack.

\section{Extension Instructions}

\subsection{\texttt{0xf1} \inst{load-ext} \parg{EXT\_STR}}

Loads the extension by the filename of \parg{EXT\_STR} from filesystem, and records it in the \texttt{opened\_exts} table. Then puts back the handle to that extension module.

\subsection{\texttt{0xf0} \inst{extcall} \parg{EXT\_ID} \parg{EXT\_CN}}

Takes two unsigned integers from the stack. Argument \parg{EXT\_ID} is for specifying the extension module handle, the other one is the call number to indicate which routine to call from the extension.

\section{Miscellaneous Instructions}

\subsection{\texttt{0x70} \inst{import} \parg{MOD\_STR} \marg{REL\_ID}}

Finds the module by the filename of \parg{MOD\_STR} and assign it's ID relative to current ID as \marg{REL\_ID}\footnote{See previous section on modules for more details.}.

TVM will assign a unique ID to every module imported based on this \parg{MOD\_STR}. For example, the module string of module \texttt{Std} from the Towel standard library (or Towelib) is \texttt{'std'} (because the source filename of it is \texttt{'std.t'}).

\subsection{\texttt{0x7f} \inst{export} \marg{UID}}

Exports the value bound by the name ID \marg{UID} to the module's \texttt{exs} field.

\subsection{\texttt{0x71} \inst{dint}}

Invokes the debug interrupt handler. See also \url{https://github.com/qwert42/ketivm/blob/master/vm/keti.py#L164}, which is an implementation of a similar instruction.

\subsection{\texttt{0x72} \inst{type} \parg{X}}

Pushes the type information of TOS onto the stack. This instruction only recognizes built-in types.

\subsection{\texttt{0xff} \inst{not-implemented}}

Prints an error message stating that an unimplemented instruction was found and the virtual machine has to exit.

\subsection{\texttt{0x0} \inst{idle}}

Does absolutely nothing.

\subsection{\texttt{0xfe} \inst{terminate}}

Terminate the Towel Virtual Machine. Or when finishing importing modules, go back to original module.

\begin{mdframed}[style=hint]
  Look at the similarities between (\inst{call}, \inst{invoke},
  etc. \texttt{->} \inst{ret}) and (\inst{import} \texttt{->}
  \inst{terminate}).
\end{mdframed}

\chapter{Bytecode Form of the Towel Assembly Language}

\section{Bytecode Form Overview}

A Towel Assembly Language source code can be compiled into a binary file. The layout of such a binary file is as follows:
\begin{itemize}
\item Magic number \texttt{0x4242}, denotes that this is a Towel binary
\item The data segment, which contains all the literals used in the original source code
\item Magic number \texttt{0xff3080ff}, denotes that data segment ends here
\item The code segment
\end{itemize}

\section{Data Segment}
A Towel binary contains only one data segment. Data segment contains all the literals used in the original source code file, which are of type \texttt{VString}, \texttt{VAtom}, \texttt{VFixedInt}, \texttt{VUFixedInt}, \texttt{VInt}, \texttt{VFloat}.

To store a string in the data segment. First, put a tag\footnote{Actually a string.} \texttt{``s''} into the data segment. After that tag, put a little endian 32-bit unsigned integer which represents the length of the string. Then put the contents of the string after the 32-bit integer.

To store an atom, put a tag \texttt{``a''} and then an unsigned little endian 64-bit integer.

To store a fixed integer, put a tag \texttt{``f''}, then a signed little endian 64-bit integer.

An unsigned fixed integer is the same as an atom, except the tag is \texttt{``u''}.

To store an integer (i.e. big integer) or a float, put their respective tags (\texttt{``b''} for integer, \texttt{``n''}\footnote{``n'' for not a number.} for float) before their binary string representations.

\begin{mdframed}[style=example]
  For a float \texttt{3.14159}, the Towel literal binary
  representation is \texttt{6e07000000332e3134313539}.
\end{mdframed}


The order of the literals are put in the data segment is their respective labels.

\section{Instruction Format}

Any bytecode instruction is a little-endian 64 bit number. The first byte of the number is \texttt{opcode}. For unary instructions, the second up to eighth bytes consists of the argument label. For binary instructions, the second up to fifth bytes consists of the first argument label, while the rest (sixth to eigth, 3 bytes, less than the first argument) consists of the second argument label.

When encountered a bytecode instruction, use the argument labels (if any) to retrieve actual arguments from data segment, and then form the actual instruction.

\begin{mdframed}[style=example]
  Suppose we have the following bytecode file:

\begin{verbatim}
  BB
    s03000000std
    u0100000000000000
    u0200000000000000
    s12000000Hello, world
    u1500000000000000
  ff3080ff

  1501000000000000
  7002000000000000
  1703000000050000
  1504000000000000
  fe00000000000000
\end{verbatim}

First, we can identify this file as a Towel bytecode because the first two bytes are \texttt{0x4242}, i.e. \texttt{BB}.

We also know that there are 5 literals in the data segment:
\begin{enumerate}
\item a string: \texttt{'std'}
\item an unsigned fixed integer 1
\item an unsigned fixed integer 2
\item a string: \texttt{'Hello, world'}
\item an unsigned fixed integer 0x15
\end{enumerate}

Then, for the first instruction (8 bytes), we get \texttt{opcode} from the first byte, in this case, \texttt{0x15}, which is \inst{push-lit} with \marg{LIT}, so we reinterpret from the 2nd to the 8th byte as an integer, 1. And get an element from the data segment by the index of one, which turns out to be the \texttt{'std'} string.\footnote{Yes, the index of data segment starts from one.}

So we can finally reconstruct the first instruction to be \texttt{PUSH\_LIT('str')}.

Now let's look at the third instruction, we lookup the \texttt{opcode} \texttt{0x17} is \inst{eval-and-push} with \marg{NID} and \marg{MID}, so we reinterpret from the 2nd to the 5th byte as an integer, i.e. 3, and 6th to 8th as another integer, 5.

Thus the two arguments are \texttt{2} and \texttt{0x15}. So we can also reconstruct this instruction to be\newline \texttt{EVAL\_AND\_PUSH(2, 0x15)}. The rest instructions are the same.

\end{mdframed}

\begin{mdframed}[style=detail]
  One of the neat things about this kind of representation is that I don't have to modify the assembler even when I have variable-sized instructions, because the addresses I'm jumping to are counted by instructions from the start, rather than bytes.
\end{mdframed}

\chapter{Extending the Towel Virtual Machine (OCaml Implementation)}

By using the Extension interface (in \texttt{src/vm/ext.ml}), you can easily add new functionalities to TVM, enabling more powerful Towel programming experience.

\section{Prerequisite}

The library (no matter if it's third-party, or of your own) should be \textbf{OCaml-compliant}, because TVM is built on top of OCaml too. That is to say, you should be able to write OCaml programs with it, thus TVM will have access to it via dynamic linking.

\begin{mdframed}[style=hint]
  I think plain C libraries with only thin OCaml wrappers (no
  \texttt{ml} files) would work too. Because \texttt{Dynlink} only
  needs it to be a OCaml-aware shared-library.
\end{mdframed}

\section{Approach}

Two instructions were implemented in TVM: \inst{load-ext} and \inst{extcall}.

\inst{load-ext} takes an \texttt{ext\_str} from the stack and loads the corresponding extension module into TVM via the OCaml standard module \texttt{Dynlink}. An \texttt{ext\_str} is a filename of the OCaml object file. After successfully loading it, the instruction leaves an unsigned integer (\texttt{OVUFixedInt}) on the stack for future reference of the extension.

\begin{mdframed}[style=hint]
   \texttt{ext\_str} should always ends with \texttt{.cmo} even if the target is a \texttt{.cmxs} file.
\end{mdframed}

\inst{extcall} takes two arguments from the stack: it first takes the TOS as the extension handle (the one \inst{load-ext} pushed), then it takes another unsigned integer as the extension function call number (although this integer will be converted into an OCaml \texttt{int}, but I think $2^{31}$ is fairly enough for ordinary libraries). The extension module then matches against the call number to determine which action to perform on the data stack.

\section{Howto}

\begin{mdframed}[style=hint]
  The following step illustrates how to build native extension rather
  than bytecode extension. If you want bytecode extension, use
  \texttt{ocamlc} instead, and probably lose some of the parameters.
\end{mdframed}

The first step, create a OCaml plugin. This plugin file is essentially a dynamic library (e.g. a \texttt{.so} file on *nix, a \texttt{.dll} file on Windows). When implementing this plugin, you must implement the module interface \texttt{TowelExtTemplate} laid out in \texttt{src/vm/ext.ml}. It's simple: one function - \texttt{extcall}. You will have to route individual call numbers to different routines using this function.

The first argument of \texttt{extcall} is the call number, then the second one is the \texttt{dss} of the VM, for you to get specific arguments from the data stack or leave your results on it. But be careful, if you ruin this dss, the TVM is doomed.

After you finish your \texttt{extcall} function and other local functions, remember to register your module value in the \texttt{\_\_ext\_\_} slot so that when loading this extension, TVM will get to know of your extension.

The second step, you compile your source code via the following command:

\begin{mdframed}[style=example]
  \texttt{ocamlfind ocamlopt -package \%1 \%2 -shared -linkall -I \%3
    -o \%4}
\end{mdframed}
Of these parameters:
\begin{itemize}
\item (\texttt{\%1}) the packages your extension module uses, take \texttt{ext\_random.ml} as an example, \texttt{\%1} will be replaced by stdint;
\item (\texttt{\%2}) the extension module source file, \texttt{ext\_random.ml}, for example;
\item (\texttt{\%3}) the directory where \texttt{t.cmi} and \texttt{nstack.cmi} are;
\item (\texttt{\%4}) the output binary filename, \texttt{ext\_random.cmxs}, for exmpale;
\item If you use some libraries that are not included in standard library, you may want to use \texttt{-linkpkg} instead of \texttt{-linkall} (for example, when building binding library for Tk).
\end{itemize}

The command for compiling the Random extension module is like this:

\begin{mdframed}[style=example]
  \texttt{ocamlfind ocamlopt -package stdint ext\_random.ml -shared
    -linkall -I ../../build/src/vm -o ext\_random.cmxs}
\end{mdframed}

Third, place the \texttt{.cmxs} file in the \texttt{libpaths} of TVM, default locations are current working directory and the folder \texttt{towelib}. Modify \texttt{src/vm/config.ml} to change these locations.

Last, write a Towel wrapper module for your extension module. In the \texttt{.w} instruction wrapper module, name \texttt{!>ext} is bound to the \inst{load-ext} instruction wrapper and name \texttt{!>>} for \inst{extcall}. You should always bind a name to the extension handle pushed by \texttt{!>ext}.

\begin{mdframed}[style=hint]
  It is often a good idea to bind a local partial applied function with the handle already applied to \texttt{!>>}.
\end{mdframed}

\part[The Implementation of the Project]{The Implementation of the Project\footnote{Special thanks to Professor Edwards for so many valuable suggestions.}}

\chapter{Project Plan}

\section{A Little Bit of History about Towel}
The original idea of Towel was to create an esoteric programming language like \textit{Shakespear} or \textit{Piet}. The central idea was that every program structure is identified by the first character. For example, \texttt{if} \texttt{is} \texttt{is-not} are all recognized as an \texttt{IF} token. And you could write a GCD program in a lorem-ipsum manner.

But this soon turned out to be infeasible when you want to name more than 26 things. So the one-character grammar idea got abandoned.

But still, I want to create something different, especially in the way the programs will look like. So I thought to myself, we already have the Lisp family (prefix), as well as the ML family (infix). Let's do postfix!\footnote{At that time, I didn't realize that there are so many postfix languages already!} Soon the idea of stack-based postfix-syntaxed functional language soon came into being. Then I named it after my favorite novel series.

\section{Specification and Development Process}

Specification was not clear at the beginning of the development, but became clearer and clearer as the development goes on.

The three of us get together every Monday afternoon before meeting with Professor Edwards. We would discuss the newly implemented parts and ideas, and hoped this discussion would identify as much flaws as possible. Then during the week, new parts would get developed, and flaws fixed.

Later in the development (after the test suite was implemented as well as several test cases), the development process began to be like Test-Driven Development spontaneously.

Manuals (or specification) were modified along development (at least for the first month) to fit what we had at that time. Later in the development, because features got added or redone too fast, they quickly went out of date, and finally got a major revision after feature freeze.

\section{Testing Process}

After each major feature was completed, one or two test cases would be created to test if the feature would work.

Not long before feature freeze, some holistic test cases were made to ensure everything works correctly together. Such test cases include, for example, \texttt{quicksort.t} for quicksort and \texttt{adv-obj.t} for advanced OO simulation.

\section{Programming Style}

Basically, we used Unix-style naming conventions, i.e. underscores.

The whole indentation rule we used was the default configuration of \texttt{ocp-indent}.

Particularly,

\begin{itemize}
\item No lines should exceed 80 characters wide.
\item Append \texttt{\_t} to most type names.
\item \texttt{in} clause starts at the second line of that
  \texttt{let-in} expression.
\item \texttt{then} and \texttt{else} clause both starts a new line, i.e.
  \begin{minted}{ocaml}
    if something
    then some other thing
    else something else
  \end{minted}
\item Prefer \texttt{begin} and \texttt{end} over parentheses.
\item Modularize the source files: the functions contained in one OCaml file should only serve one purpose. Except some modules, such as \texttt{Common}.
\item \texttt{let}, \texttt{try}, \texttt{if}, and \texttt{match} starts right after \texttt{in}, \texttt{then}, or \texttt{else}:
  \begin{minted}{ocaml}
    let x = Some(1)
    in if something
    then try if something
             then ahh
             else ohh
         with Error ->
           failwith ``something is wrong''
    else match a with
        Some(x) -> x
      | None -> failwith ``nothing here''
  \end{minted}
\end{itemize}

\section{Project Timeline}

We had no designated project timeline whatsoever. By the time I consider the language to have become stable, it was about two weeks before the report due. Obviously, we got lucky.

Here's the major changes made in the code repository:

\begin{itemize}
\item Sep 24: THE Initial Commit.
\item Sep 27: Proposal commited.
\item Oct 9: Somewhat working scanner and parser.
\item Oct 20: LRM commited.
\item Nov 8: Got a working compiler.
\item Nov 15: Hello world!
\item Nov 17: Towel standard library commited.
\item Nov 29: Major change to the VM.
\item Dec 3: Extension mechanism added to the VM.
\item Dec 4: The language become dynamic officially (dynatowel branch merged into master).
\item Dec 6: Bytetowel merged.
\item Dec 8: Feature freeze.
\end{itemize}

\section{Roles and Responsibilities}

\begin{itemize}
\item Project Manager: None
\item The Guru Guy: Zihang Chen
\item System Architect: Zihang Chen
\item Testers: Zihang Chen, Baochan Zheng, Guanlin Chen
\end{itemize}
\section{Tools and Languages Used in Developemnt}

\begin{itemize}
\item Emacs 24.5 with \texttt{tuareg-mode} (OCaml syntax
  highlighting), \texttt{merlin} (syntax and semantics checking,
  linting) and \texttt{ocp-indent} (indenting OCaml). These are
  recommended by the \texttt{opam} official website.

\item Ruby 2.2.3 is used for test automation and compiler/VM source code
  generation (to write as less boilerplate code as possible).

\item Waf (a Python3 tool) is used for the building framework of the
  project, Python3 is used for the building script.

\item \XeTeX{} for document compilation and AUCTeX for \LaTeX ~editing.

\item \texttt{opam} for installing OCaml packages, \texttt{findlib} for compiling my source code with the packages, and \texttt{ocamldebug} for some information on stack trace. Overall package usage: \texttt{Batteries}, \texttt{Stdint}, \texttt{Sha}, \texttt{Extlib}, \texttt{menhir}.

\item Git for project version control, GitHub for project hosting, and Google for some of the problem solving. English for understanding the OCaml and Batteries manual, also the solutions I found on Stackoverflow.
\end{itemize}

\section{Project Log}

See Appendix \autoref{project-log}.

\chapter{Architectural Design}

\section{Overall}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[ roundnode/.style={circle, draw=green!60,
      fill=green!5, very thick, minimum size=3cm},
    squarednode/.style={rectangle, draw=red!60, fill=red!5, very
      thick, minimum size=3cm}, ]
    % Nodes
    \node[squarednode] (sourcecode) {Source code}; \node[roundnode]
    (compiler) [right=of sourcecode] {Compiler}; \node[squarednode]
    (ir) [below right=-0.5cm and 1cm of compiler] {IR}; \node[roundnode] (vm) [below=of
    compiler] {Virtual Machine}; \node[squarednode] (output) [left=of
    vm] {42};
    % Lines
    \draw[->] (sourcecode.east) -- (compiler.west); \draw[->]
    (compiler.east) -- (ir.north); \draw[->] (ir.south) -- (vm.east);
    \draw[->] (vm.west) -- (output.east);
  \end{tikzpicture}
  
  \caption{Overall Architecture}
  \label{fig:overall}
\end{figure}

\subsection{The Towel Compiler (Zihang Chen)}

  The compiler frontend (module \texttt{Weave}) first invokes \texttt{Switches.parse} to parse the switch configuration for the source code. Then it gets the abstract syntax tree out of the source code by tokenizing and parsing it with modules \texttt{Scanner.token} and \texttt{Parser.sentence}.

  Then it invokes module \texttt{Compile.compile} to transform the AST data structure to the AST of intermediate representation (or AST of bytecode). During this phase, \texttt{Compile} makes use of \texttt{Cseg.(|\mtilde ~\mtilde ~|)} and \texttt{Tasm\_ast} to build the IR AST.

  \begin{mdframed}[style=detail]
    Module \texttt{Cseg} defines an infix operator \texttt{(|\mtilde ~\mtilde ~|)} to represent the concatenation of two \texttt{Tasm\_ast.asm} into one. This greatly simplifies the work for code generation.

    The \texttt{Compile.compile} function basically invokes the code generation function \texttt{Compile.g\_word} for each word in the AST. And for each kind of word, \texttt{Compile.g\_word} call all kinds of other code generation functions, for example, for \texttt{Ast.WFunction}, it calls \texttt{Compile.g\_fun}.
  \end{mdframed}

  With the IR AST, the compiler invokes \texttt{assemble.ml:assemble} to get rid of all the labels, and replace them with absolute positions. After this step, the compiler gets Assembled IR AST.

  In the last step, the compiler invokes \texttt{tasm\_bytecode.ml:b\_asm} to get the bytecode representation of the IR.

  \begin{mdframed}[style=hint]
  The above mainly talked about the very common invocation to the compiler, for other uses, for example, outputing text version of Assembled IR AST, the compiler uses \texttt{tasm\_stringify.ml:p\_asm}.

  See also \autoref{fig:compiler-arch}.
  \end{mdframed}

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[ roundnode/.style={circle, draw=green!60,
      fill=green!5, very thick, minimum size=2cm},
    squarednode/.style={rectangle, draw=red!60, fill=red!5, very
      thick, minimum size=2cm}, ]
    % Nodes
    \node[squarednode] (sourcecode) {Source code}; \node[roundnode] (switches) [right=of sourcecode] {Switches.parse}; \node[roundnode]
    (scanner) [right=of switches] {Tokenize}; \node[roundnode]
    (parser) [right=of scanner] {Parse}; \node[roundnode] (compile)
    [below left=1.2cm and 0cm of parser] {Compile}; \node[squarednode]
    (ast_ir) [below=of compile] {IR AST}; \node[roundnode] (assemble)
    [below left=1.2cm and 0cm of ast_ir] {Assemble}; \node[roundnode]
    (stringify_raw) [below right=1.2cm and 0cm of ast_ir] {Stringify};
    \node[squarednode] (raw) [below right=of stringify_raw] {Raw IR};
    \node[roundnode] (ir_stringify) [below left=1.2cm and 0cm of
    assemble] {Stringify}; \node[squarednode] (asm_ir) [below=of
    ir_stringify] {Assembled IR}; \node[roundnode] (bytecode) [below
    right=1.2cm and 0cm of assemble] {Bytecode}; \node[squarednode]
    (bc_ir) [below=of bytecode] {Bytecode IR};
    % Lines
    \draw[->] (sourcecode.east) -- (switches.west); \draw[->] (switches.east) -- (scanner.west); \draw[->]
    (scanner.east) -- (parser.west); \draw[->] (parser.south west) --
    (compile.north); \draw[->] (compile.south) -- (ast_ir.north);
    \draw[->] (ast_ir.south) -- (assemble.north east); \draw[->]
    (ast_ir.south) -- (stringify_raw.north west); \draw[->]
    (assemble.south) -- (ir_stringify.north east); \draw[->]
    (assemble.south) -- (bytecode.north west); \draw[->]
    (stringify_raw.south east) -- (raw.north west); \draw[->]
    (ir_stringify.south) -- (asm_ir.north); \draw[->] (bytecode.south)
    -- (bc_ir.north);
  \end{tikzpicture}
  \caption{Compiler Architecture}
  \label{fig:compiler-arch}
\end{figure}

\subsection{The Towel Virtual Machine (Zihang Chen)}

Things are much simpler on the VM-side. The virtual machine frontend \texttt{Tvm} first reads in the bytecode representation of IR, transform it back into IR AST by \texttt{Tasm\_inv\_bytecode.parse\_bytecode}. Then invokes \texttt{Nvm.exec} to execute all the instructions parsed.

The function \texttt{Nvm.exec} basically implements all the instructions available. However, for certain instructions that are quite alike, for example, the arithmetic instructions and branching instructions, we use Ruby scripts to generate respective code for them, then invoke them in \texttt{Nvm.exec}.\footnote{An alternative to do this is by \texttt{camlp4}.}

\begin{mdframed}[style=example]
  \texttt{Nvm.exec} calls \texttt{Jumps.branch} to do branching, which is generated by \texttt{jmg.rb} (jump generator) before the project is built.
\end{mdframed}

\begin{mdframed}[style=detail]
The \texttt{Nvm.exec} depends on many other functions from other modules to work. For example,

\begin{itemize}
\item The module \texttt{T} provides all the basic data types for the TVM, an example would be the value type \texttt{T.value\_t}.

\item The module \texttt{Vm\_t} provides various data types specific for this implementation of the TVM, such as \texttt{Vm\_t.flags\_t}.

\item The module \texttt{Nstack} provides support for the stack data
  structure and various operations used by \texttt{Nvm.exec}.

\item The module \texttt{Arithmetics} (Baochan Zheng, Guanlin Chen) provides implementation for various arithmetics instructions.

\item The module \texttt{Jumps} we've talked above provides branching control.

\item The module \texttt{Dscoping} provides data structure and operations for dynamic scoping.

\item The module \texttt{Ext} implements extension (plugin) mechanism for \inst{load-ext} and \inst{extcall}.
\end{itemize}
\end{mdframed}

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[ roundnode/.style={circle, draw=green!60,
      fill=green!5, very thick, minimum size=2cm},
    squarednode/.style={rectangle, draw=red!60, fill=red!5, very
      thick, minimum size=2cm}]
    \node[squarednode] (bc_ir) {Bytecode IR};
    \node[roundnode] (bc_inv) [below=of bc_ir] {Bytecode Parser};
    \node[squarednode] (ir_ast) [below=of bc_inv] {IR AST};
    \node[roundnode] (exec) [below=of ir_ast] {\texttt{exec}};
    \node[squarednode] (output) [below=of exec] {Output};
    \node[squarednode] (mods) [below right=0cm and 1cm of ir_ast] {Other Bytecode Modules};
    \node[roundnode] (ext_) [below left=0cm and 1cm of ir_ast] {\texttt{ext.ml}};
    \node[squarednode] (exts) [below right=0cm and 1.3cm of exec] {Other Extension Modules};
    \node[roundnode] (nstack) [below left=0cm and 1.3cm of exec] {...};
    \draw[->] (bc_ir.south) -- (bc_inv.north);
    \draw[->] (bc_inv.south) -- (ir_ast.north);
    \draw[->] (ir_ast.south) -- (exec.north);
    \draw[->] (exec.south) -- (output.north);
    \draw[->] (mods.west) -- (exec.east);
    \draw[->] (ext_.east) -- (exec.west);
    \draw[->] (nstack.east) -- (exec.west);
    \draw[->] (exts.west) -- (exec.east);
  \end{tikzpicture}
  \caption{Virtual Machine Architecture}
  \label{fig:vm-arch}
\end{figure}

\chapter{Test Plan}

\section{Individual Test Examples}

\subsection{\texttt{partial.t}}
\begin{mdframed}[style=example]
\begin{verbatim}
  "---
  Tests partial function application.
  !>>
  !<< 42
  41
  [2 2]
  "

  import 'std' \

  bind Dec1 (1 -\Std)
  then (43 Dec1 !println\Std 42 Dec1 !println\Std)
\end{verbatim}
\end{mdframed}

The assembled text form of the IR is as follows:

\begin{mdframed}[style=example]
\begin{verbatim}
  push-stack
  push-scope
  push-lit 'std'
  import 1u
  push-scope
  call 15u
  bind 1u
  push-lit 43
  eval-and-push 1u 0u
  eval-and-push 25u 1u
  push-lit 42
  eval-and-push 1u 0u
  eval-and-push 25u 1u
  pop-scope
  terminate
  push-stack
  push-lit 1
  eval-and-push 4u 1u
  ret
\end{verbatim}
\end{mdframed}

The assembled binary form of the IR is as follows:

\begin{mdframed}[style=example]
\begin{verbatim}
  4242 7303 0000 0073 7464 7501 0000 0000
  0000 0075 0f00 0000 0000 0000 662b 0000
  0000 0000 0075 0000 0000 0000 0000 7519
  0000 0000 0000 0066 2a00 0000 0000 0000
  6601 0000 0000 0000 0075 0400 0000 0000
  0000 ff30 80ff 2000 0000 0000 0000 0100
  0000 0000 0000 1501 0000 0000 0000 7002
  0000 0000 0000 0100 0000 0000 0000 2803
  0000 0000 0000 0402 0000 0000 0000 1504
  0000 0000 0000 1702 0000 0005 0000 1706
  0000 0002 0000 1507 0000 0000 0000 1702
  0000 0005 0000 1706 0000 0002 0000 0200
  0000 0000 0000 fe00 0000 0000 0000 2000
  0000 0000 0000 1508 0000 0000 0000 1709
  0000 0002 0000 2400 0000 0000 0000
\end{verbatim}
\end{mdframed}

\subsection{\texttt{bind.t}}

\begin{mdframed}[style=example]
\begin{verbatim}
  "---
  Tests if nested bind and also works.
  !>>
  !<< 3
  -1
  5
  3
  10
  -2
  9
  3
  12
  11
  "

  import 'std' \

  bind A fun` B,
    bind C fun` D,
      bind E (1 2 -\Std)
      then (((E !println\Std D !println\Std B !println\Std 10)))
    also F fun` D,
      bind E (5 7 -\Std)
      then (E !println\Std D !println\Std B !println\Std 12)
    then (B !println\Std 5 C !println\Std 9 F !println\Std 11)
  then (3 A !println\Std)
\end{verbatim}
\end{mdframed}

The assembled text form of the IR is as follows:

\begin{mdframed}[style=example]
\begin{verbatim}
   push-stack
   push-scope
   push-lit 'std'
   import 1u
   push-scope
   push-fun 12u
   bind 1u
   push-lit 3
   eval-and-push 1u 0u
   eval-and-push 25u 1u
   pop-scope
   terminate
   push-stack
   push-scope
   install
   fun-arg 2u
   push-scope
   push-fun 57u
   bind 3u
   closure 2u
   push-fun 35u
   bind 6u
   closure 2u
   eval-and-push 2u 0u
   eval-and-push 25u 1u
   push-lit 5
   eval-and-push 3u 0u
   eval-and-push 25u 1u
   push-lit 9
   eval-and-push 6u 0u
   eval-and-push 25u 1u
   push-lit 11
   pop-scope
   pop-scope
   ret
   push-stack
   push-scope
   install
   fun-arg 4u
   push-scope
   call 52u
   bind 5u
   eval-and-push 5u 0u
   eval-and-push 25u 1u
   eval-and-push 4u 0u
   eval-and-push 25u 1u
   eval-and-push 2u 0u
   eval-and-push 25u 1u
   push-lit 12
   pop-scope
   pop-scope
   ret
   push-stack
   push-lit 5
   push-lit 7
   eval-and-push 4u 1u
   ret
   push-stack
   push-scope
   install
   fun-arg 4u
   push-scope
   call 80u
   bind 5u
   call 68u
   pop-scope
   pop-scope
   ret
   push-stack
   call 71u
   ret
   push-stack
   eval-and-push 5u 0u
   eval-and-push 25u 1u
   eval-and-push 4u 0u
   eval-and-push 25u 1u
   eval-and-push 2u 0u
   eval-and-push 25u 1u
   push-lit 10
   ret
   push-stack
   push-lit 1
   push-lit 2
   eval-and-push 4u 1u
   ret
\end{verbatim}
\end{mdframed}

The assembled binary form of the IR is as follows:

\begin{mdframed}[style=example]
\begin{verbatim}
  4242 7303 0000 0073 7464 7501 0000 0000
  0000 0075 0c00 0000 0000 0000 6603 0000
  0000 0000 0075 0000 0000 0000 0000 7519
  0000 0000 0000 0075 0200 0000 0000 0000
  7539 0000 0000 0000 0075 0300 0000 0000
  0000 7523 0000 0000 0000 0075 0600 0000
  0000 0000 6605 0000 0000 0000 0066 0900
  0000 0000 0000 660b 0000 0000 0000 0075
  0400 0000 0000 0000 7534 0000 0000 0000
  0075 0500 0000 0000 0000 660c 0000 0000
  0000 0066 0700 0000 0000 0000 7550 0000
  0000 0000 0075 4400 0000 0000 0000 7547
  0000 0000 0000 0066 0a00 0000 0000 0000
  6601 0000 0000 0000 0066 0200 0000 0000
  0000 ff30 80ff 2000 0000 0000 0000 0100
  0000 0000 0000 1501 0000 0000 0000 7002
  0000 0000 0000 0100 0000 0000 0000 1003
  0000 0000 0000 0402 0000 0000 0000 1504
  0000 0000 0000 1702 0000 0005 0000 1706
  0000 0002 0000 0200 0000 0000 0000 fe00
  0000 0000 0000 2000 0000 0000 0000 0100
  0000 0000 0000 f200 0000 0000 0000 0507
  0000 0000 0000 0100 0000 0000 0000 1008
  0000 0000 0000 0409 0000 0000 0000 2607
  0000 0000 0000 100a 0000 0000 0000 040b
  0000 0000 0000 2607 0000 0000 0000 1707
  0000 0005 0000 1706 0000 0002 0000 150c
  0000 0000 0000 1709 0000 0005 0000 1706
  0000 0002 0000 150d 0000 0000 0000 170b
  0000 0005 0000 1706 0000 0002 0000 150e
  0000 0000 0000 0200 0000 0000 0000 0200
  0000 0000 0000 2400 0000 0000 0000 2000
  0000 0000 0000 0100 0000 0000 0000 f200
  0000 0000 0000 050f 0000 0000 0000 0100
  0000 0000 0000 2810 0000 0000 0000 0411
  0000 0000 0000 1711 0000 0005 0000 1706
  0000 0002 0000 170f 0000 0005 0000 1706
  0000 0002 0000 1707 0000 0005 0000 1706
  0000 0002 0000 1512 0000 0000 0000 0200
  0000 0000 0000 0200 0000 0000 0000 2400
  0000 0000 0000 2000 0000 0000 0000 150c
  0000 0000 0000 1513 0000 0000 0000 170f
  0000 0002 0000 2400 0000 0000 0000 2000
  0000 0000 0000 0100 0000 0000 0000 f200
  0000 0000 0000 050f 0000 0000 0000 0100
  0000 0000 0000 2814 0000 0000 0000 0411
  0000 0000 0000 2815 0000 0000 0000 0200
  0000 0000 0000 0200 0000 0000 0000 2400
  0000 0000 0000 2000 0000 0000 0000 2816
  0000 0000 0000 2400 0000 0000 0000 2000
  0000 0000 0000 1711 0000 0005 0000 1706
  0000 0002 0000 170f 0000 0005 0000 1706
  0000 0002 0000 1707 0000 0005 0000 1706
  0000 0002 0000 1517 0000 0000 0000 2400
  0000 0000 0000 2000 0000 0000 0000 1518
  0000 0000 0000 1519 0000 0000 0000 170f
  0000 0002 0000 2400 0000 0000 0000
\end{verbatim}
\end{mdframed}

\section{Holistic Test Example: Quicksort}

\begin{mdframed}[style=example]
\begin{verbatim}
  "---
  Holistic test: Quicksort.
  !>>
  !<< [1 2 3 4 5]
  "

  import 'std' \

  bind #quicksort ,\ L,
    (L ?#empty\Std ift (!!pop\Std []), (!!pop\Std
      bind ~h (L #hd\Std)
      also ~t (L #tl\Std)
      then (~t (~h >\Std) /filter\Std #quicksort
            [~h]
            ~t (~h <=\Std) /filter\Std #quicksort
        #concat\Std #concat\Std)))
  then ([5 4 3 2 1] #quicksort !println\Std)
\end{verbatim}
\end{mdframed}

The assembled text form of the IR is as follows:

\begin{mdframed}[style=example]
\begin{verbatim}
  push-stack
  push-scope
  push-lit 'std'
  import 1u
  push-scope
  push-fun 19u
  bind 1u
  closure 1u
  push-lnil
  push-lit 5
  push-lit 4
  push-lit 3
  push-lit 2
  push-lit 1
  end-list
  eval-and-push 1u 0u
  eval-and-push 25u 1u
  pop-scope
  terminate
  push-stack
  push-scope
  install
  fun-arg 2u
  eval-and-push 2u 0u
  eval-and-push 36u 1u
  jf 30u
  eval-and-push 27u 1u
  push-lnil
  end-list
  jump 50u
  eval-and-push 27u 1u
  push-scope
  call 64u
  bind 3u
  call 60u
  bind 4u
  eval-and-push 4u 0u
  call 56u
  eval-and-push 59u 1u
  eval-and-push 1u 0u
  push-lnil
  eval-and-push 3u 0u
  end-list
  eval-and-push 4u 0u
  call 52u
  eval-and-push 59u 1u
  eval-and-push 1u 0u
  eval-and-push 57u 1u
  eval-and-push 57u 1u
  pop-scope
  pop-scope
  ret
  push-stack
  eval-and-push 3u 0u
  eval-and-push 13u 1u
  ret
  push-stack
  eval-and-push 3u 0u
  eval-and-push 10u 1u
  ret
  push-stack
  eval-and-push 2u 0u
  eval-and-push 32u 1u
  ret
  push-stack
  eval-and-push 2u 0u
  eval-and-push 30u 1u
  ret
\end{verbatim}
\end{mdframed}

The assembled binary form of the IR is as follows:

\begin{mdframed}[style=example]
\begin{verbatim}
  4242 7303 0000 0073 7464 7501 0000 0000
  0000 0075 1300 0000 0000 0000 6605 0000
  0000 0000 0066 0400 0000 0000 0000 6603
  0000 0000 0000 0066 0200 0000 0000 0000
  6601 0000 0000 0000 0075 0000 0000 0000
  0000 7519 0000 0000 0000 0075 0200 0000
  0000 0000 7524 0000 0000 0000 0075 1e00
  0000 0000 0000 751b 0000 0000 0000 0075
  3200 0000 0000 0000 7540 0000 0000 0000
  0075 0300 0000 0000 0000 753c 0000 0000
  0000 0075 0400 0000 0000 0000 7538 0000
  0000 0000 0075 3b00 0000 0000 0000 7534
  0000 0000 0000 0075 3900 0000 0000 0000
  750d 0000 0000 0000 0075 0a00 0000 0000
  0000 7520 0000 0000 0000 00ff 3080 ff20
  0000 0000 0000 0001 0000 0000 0000 0015
  0100 0000 0000 0070 0200 0000 0000 0001
  0000 0000 0000 0010 0300 0000 0000 0004
  0200 0000 0000 0026 0200 0000 0000 0011
  0000 0000 0000 0015 0400 0000 0000 0015
  0500 0000 0000 0015 0600 0000 0000 0015
  0700 0000 0000 0015 0800 0000 0000 0013
  0000 0000 0000 0017 0200 0000 0900 0017
  0a00 0000 0200 0002 0000 0000 0000 00fe
  0000 0000 0000 0020 0000 0000 0000 0001
  0000 0000 0000 00f2 0000 0000 0000 0005
  0b00 0000 0000 0017 0b00 0000 0900 0017
  0c00 0000 0200 0038 0d00 0000 0000 0017
  0e00 0000 0200 0011 0000 0000 0000 0013
  0000 0000 0000 0030 0f00 0000 0000 0017
  0e00 0000 0200 0001 0000 0000 0000 0028
  1000 0000 0000 0004 1100 0000 0000 0028
  1200 0000 0000 0004 1300 0000 0000 0017
  1300 0000 0900 0028 1400 0000 0000 0017
  1500 0000 0200 0017 0200 0000 0900 0011
  0000 0000 0000 0017 1100 0000 0900 0013
  0000 0000 0000 0017 1300 0000 0900 0028
  1600 0000 0000 0017 1500 0000 0200 0017
  0200 0000 0900 0017 1700 0000 0200 0017
  1700 0000 0200 0002 0000 0000 0000 0002
  0000 0000 0000 0024 0000 0000 0000 0020
  0000 0000 0000 0017 1100 0000 0900 0017
  1800 0000 0200 0024 0000 0000 0000 0020
  0000 0000 0000 0017 1100 0000 0900 0017
  1900 0000 0200 0024 0000 0000 0000 0020
  0000 0000 0000 0017 0b00 0000 0900 0017
  1a00 0000 0200 0024 0000 0000 0000 0020
  0000 0000 0000 0017 0b00 0000 0900 0017
  0d00 0000 0200 0024 0000 0000 0000 00
\end{verbatim}
\end{mdframed}

\section{The Test Suite Script: Prefect (Zihang Chen)}

When Prefect is invoked, it automatically searches the current working directory for files with extension \texttt{.t}. For each \texttt{.t} file, if the filename starts with two underscores, it is simply ignored.

The test input and expected output are all embedded in the comments of their respective test case files:

\begin{mdframed}[style=example]
\begin{verbatim}
  "Some optional background or rationale description of this test case.
  ---
  Mandatory test case description
  !>> optional test input
  !<< optional expected output"
\end{verbatim}
\end{mdframed}

A test is said to be passed if and only if it exits normally and print to the standard output exactly the expected output.

\begin{mdframed}[style=cl]
  \begin{minted}{ruby}
#! /usr/bin/env ruby

require 'open3'
require 'colorize'

class Prefect
  # This class tests per file.
  IN_PREFIX = '!>> ?'
  OUT_PREFIX = '!<< ?'

  PAT = /.*".*---\n(.*)\n#{IN_PREFIX}([^"]*)\n#{OUT_PREFIX}([^"]*)"/m
  # This means that a testcase description consists of three parts:
  # (1) the text description part that tells what this testcase is about
  # (2) the input part, led by !>>\space
  # (3) the expected output part, led by !<<\space

  def initialize(fp, **ctx)
    @ctx = ctx
    @fp = fp.chop.chop

    open(fp) {|f|
      @content = f.read
    }

    extract_info
  end

  def extract_info
    matches = PAT.match(@content)
    unless matches.nil?
      @description, @input, @expected_output = matches.captures
      @description.strip!
    end
  end

  def execute_ok(idx)
    pretty_input = if @input == ''
                     'None'.light_cyan
                   else
                     @input.white
                   end
    pretty_output = if @expected_output == ''
                      'None'.light_cyan
                    else
                      @expected_output.white
                    end

    puts "Testcase #{('#' + idx.to_s).blue}: #{@description}
---
Input: #{pretty_input}
Output: #{pretty_output}"

    out, err, status = Open3.capture3(@ctx[:weave_path],
                                    "#{@fp}.t",
                                    '-o',
                                    "temp/#{@fp}.w")

    if status.exitstatus != 0
      [false, out]
      return
    end

    if ARGV[0] == '-t'
      puts "Tracing #{@fp}.w =>"
      output, _ = Open3.capture2(
          @ctx[:tvm_path], "temp/#{@fp}.w", '-t', :stdin_data=>@input
      )
    else
      output, err, status = Open3.capture3(
          @ctx[:tvm_path], "temp/#{@fp}.w", :stdin_data=>@input
      )
    end

    if status.exitstatus != 0
      [false, err]
      return
    end

    if output == @expected_output
      [true, output]
    else
      [false, output]
    end
  end
end

if __FILE__ == $0
  require 'fileutils'
  FileUtils.remove_entry_secure 'temp'
  FileUtils.mkdir 'temp'

  SUFFIX = 't'
  WEAVE_PATH = '../build/src/compiler/weave'
  TVM_PATH = '../build/src/vm/tvm'
  make_prefect = lambda {|fp| Prefect.new(
    fp,
    :weave_path=>WEAVE_PATH,
    :tvm_path=>TVM_PATH
  )}

  cnt = 0
  results = {}
  Dir.foreach '.' do |entry|
    if entry =~ /[^.]*\.#{SUFFIX}/
      if entry.start_with? '__'
        next
      end

      cnt += 1
      ok, out = make_prefect.call(entry).execute_ok cnt

      puts "Real output: #{out}\n"
      if ok
        results[entry] = :ok
        puts "#{entry} =====> #{'[OK]'.green}"
      else
        results[entry] = :failed
        puts "#{entry} =====> #{'[FAILED]'.red}"
      end

      puts '-' * 42
    end
  end

  count = results.inject({:ok => 0, :failed => 0}) do |acc, kv|
    _, v = kv
    acc[v] += 1
    acc
  end

  if count != {}
    if count[:ok] > 0
      ok = count[:ok].to_s.green
    else
      ok = 0.to_s
    end

    if count[:failed] > 0
      failed = count[:failed].to_s.red
    else
      failed = 0.to_s
    end
    puts "Summary: #{ok} passed, #{failed} failed."
  end
end
  \end{minted}
\end{mdframed}

\section{Tests Overview (Zihang Chen)}

16 tests were included in the test suite.

\begin{itemize}
\item \texttt{bind.t}

tests whether nested \texttt{bind} forms and \texttt{also} clauses work or not.

\item \texttt{functional.t}

tests some of the functional features of Towel, for example, currying.

\item \texttt{gcd.t}

tests if tail recursion and chained \texttt{if} forms work.

\item \texttt{idle.t}

tests if \texttt{.idle} works.

\item \texttt{ift-iff.t}

tests whether \texttt{ife}, \texttt{ifne}, \texttt{ift}, \texttt{iff} and phonies work.

\item \texttt{import.t}

tests whether implicit import and explicit import work as expected.

\item \texttt{list.t}

tests various functions for enumerables, for example, \mstd{\#hd}, \mstd{\#t1}, etc.

\item \texttt{macro.t}

tests if shared sequences work, also tests the expressiveness of Towel.

\item \texttt{obj.t}

mimic an object-oriented programming situation, intended as testing for function closures.

\item \texttt{partial.t}

tests if partial function application is stable.

\item \texttt{phony.t}

tests if phony, partial function application and \mstd{!invoke} can work together.

\item \texttt{quicksort.t}

a holistic test, tests if non-tail recursion, the stability of \texttt{bind-then} forms in non-tail recursive environment, list functions, and the overall stability of the virtual machine.

\item \texttt{rnd.t}

tests if the extension mechanism of the virtual machine works.

\item \texttt{test.t}

the hello world test.

\end{itemize}

\chapter{Lessons Learned}

\section{Don't Panic!}

First of all, OCaml is great (but not perfect). Be patient and learn how to program in OCaml. It will change your life.

Discuss your ideas with your teammates, explain your code to people, fix your bugs right away. If you cannot explain your idea or code to others, you don't understand them at all.

Don't be afraid to rewrite 90\% of your code. And make sure every time you do this, you reduce 10\% of the code.

\subsection{Some Practical Advices}
\begin{enumerate}
\item RTFM!! It is hard to understand even the words in them at first, but you'll get to the gist after reading them for 10 times.

\item Code style matters.

\item Use GitHub to host your code, enjoy the little deep green squares in your Contributions chart.

\item Use \texttt{opam}, \texttt{Batteries} and \texttt{Findlib}. Learn to program OCaml in Emacs, or at least Vim. Never program in Sublime Text.

\item When in trouble, first use \texttt{ocamldebug} to see the backtrace and identify the line number where your program blows up. Then use print to debug. (And maybe the time travel feature of \texttt{ocamldebug}.)\footnote{Because OCaml loses most of the type information after compilation, you can't really get something useful out of the debugger.}

\item Always wrap \texttt{Hashtbl.find} in a \texttt{try} expression, because it's really frustrating to see only a \texttt{Failure: Not\_found} printed when your program runs into trouble.

\item Don't panic.
\end{enumerate}

\begin{appendices}
\chapter{Project Log (up to Dec 10)}
\label{project-log}

\begin{verbatim}
commit 6b14ac3fb7e502749f1b4427ddd5d48f4d647b66
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Sep 24 09:30:45 2015 -0400

    Initial commit

commit be3c048d649099ceb8fdc0c0a65d2e3e089086af
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Sep 27 01:16:57 2015 -0400

    proposal 1

commit 561f4165f5af9d831ad91b74b4267a39a70ce068
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Oct 7 17:23:45 2015 -0400

    first stage of lexer and parser and ast types

commit d3999c3048c620333be23f4420f7aaa19147d422
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Oct 8 00:18:40 2015 -0400

    compilable version, which unfortunately wont work, but debuggable with menhir

commit cf6b0de9ceacab07d9fcf23814f4e479cd32a5a3
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Oct 8 09:28:02 2015 -0400

    compact ast, removed most of the `list(word)`

commit c04f7a82d120571264f9bb1b1be5a5c68c415029
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Oct 8 09:37:55 2015 -0400

    temporarily stash

commit 28c19f77f610756727428fe43774456abc1e6cd1
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Oct 8 13:22:20 2015 -0400

    reduce AT and add BQUOTE backquote

commit b0f3c4255d355dea0b1dbb25e5a3fc958a80177f
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Oct 8 13:26:02 2015 -0400

    add BQUOTE backquote

commit 0bc4304992fecb3927b2db6b096f3f280e2d5cc4
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Oct 9 20:53:56 2015 -0400

    no warnings

commit 68bfc48a5b2875c9a255f95058c684b3d3737255
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Oct 9 20:57:53 2015 -0400

    enhance namespace resolving

commit 10f3f091ddfac20e885cb90d8271e51dd9e921a1
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Oct 10 02:09:38 2015 -0400

    somewhat working parser and lexer

commit 4ca60339a2c2aad4e757b5bed40e4ec649c891e7
Merge: 28c19f7 10f3f09
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Oct 10 02:16:08 2015 -0400

    merge from compact-ast

commit 1594b9903a7c6dc002357569a113f2ed22bbfdd5
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Oct 10 02:42:03 2015 -0400

    redesign type definition

commit a4ae88601b412909d1074eb47dc002f6eb4a0e8a
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Oct 10 18:10:49 2015 -0400

    change bind-in to bind-then, remove bind

commit 1a95d291dfb4837d3db8917ba1fbf13d0af4ac38
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Oct 10 18:13:54 2015 -0400

    organize structure

commit 36345fdad8ce4833610ea3c6fbf500c56af583fb
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Oct 10 18:26:06 2015 -0400

    add .tar.gz target

commit 0582ba86d341cfd3b9e2fd0e9a8322322a1ba097
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 12 17:06:11 2015 -0400

    remove lots of ifs

commit eb2ecb7f87883811439bbac337b35d2f4c86fc71
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 12 17:06:37 2015 -0400

    remove lots of ifs

commit 79039e946ed81e7182d492992d6d5e70b04e09b4
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 12 17:07:26 2015 -0400

    lots of improvements

commit 1f5ad1a1899bca7e2accccc31e90a3c172d48f29
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 12 17:22:15 2015 -0400

    change seq delim to braces

commit 2423bd073a05efc2d316aed53c6e70007140018e
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 12 17:22:39 2015 -0400

    update eval rule

commit cd214c23d826223423a542d8cee2eb2465f833fd
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 12 23:09:48 2015 -0400

    add ifs again and fine-tuned error messages

commit 3fca92d6e65341559604b171c540dba962b05a35
Merge: 2423bd0 cd214c2
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 12 23:13:21 2015 -0400

    Merge pull request #1 from qwert42/rich-preds
    
    add ifs again and fine-tuned error messages

commit c305ffd451492aec8dbd04a4be069e3d16b62726
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Oct 13 13:55:59 2015 -0400

    update makefile

commit 10e55e7578295da69a1d7fa914c85b9cacd4829b
Merge: 3fca92d c305ffd
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Oct 13 13:56:27 2015 -0400

    Merge pull request #2 from qwert42/rich-preds
    
    update makefile

commit e74b5e1ac9a10b904bf094eb54c9f55721989676
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Oct 14 20:11:03 2015 -0400

    stash

commit 7e9a8e97ed13db3cd545703cc4502eb2fe60af49
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Oct 15 18:35:09 2015 -0400

    add bind also

commit 0bf11ece77103f2dcd4c0b0a1284b6ff03126e0c
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Oct 16 13:46:20 2015 -0400

    add type declaration grammar

commit ea1c5b36d500664495fd7b0e5c751e522c19a72d
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Oct 16 14:42:55 2015 -0400

    fix premature terminator

commit a8f41d13a1670659c028fecc8ba78b98cdabea1b
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Oct 16 21:28:57 2015 -0400

    add altype literal grammar

commit e931e1541da05b287ff3983193274c0704291561
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Oct 16 21:32:22 2015 -0400

    update adtsf grammar definition

commit 3bd462816f709a3c2a38823316bd389a8ca0dbf5
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Oct 17 19:16:37 2015 -0400

    fix negative number scanning

commit 904b1e7c1ef966809702e4fa0ed37a92d423036b
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Oct 17 19:17:04 2015 -0400

    add example for elements of programs

commit 4718ce6534ccc1098157268d4173901d805cc536
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Oct 17 20:57:11 2015 -0400

    add more descriptions

commit 2e2d004476a4399e2569cce34a990de1328789e3
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Oct 18 01:53:02 2015 -0400

    add something new

commit f42c3fa063286c4fe36eb17d24f178e9c6b6a425
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Oct 18 12:14:23 2015 -0400

    fix escape sequence scanning

commit 4a7e0c63348616400d1b78c43b68dac0733e086a
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Oct 18 22:56:31 2015 -0400

    fix typo

commit 6e87374d69a457e28622fa722c6c4a80793482e2
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Oct 18 23:25:17 2015 -0400

    Update quicksort.w

commit 07d9e15f17591658ecb3819464f46834ca63f997
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 19 00:19:30 2015 -0400

    add comments for review

commit c1d21192764b8b53a01f8557862fa4681b4a18f3
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 19 00:21:06 2015 -0400

    Update quicksort.w

commit c7b6e801693b9a1a28f549403c3d2898bdf81521
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 19 00:51:13 2015 -0400

    Update gcd.w

commit cb9061eade02ffb6fa0adc0b278853ab7a873f4d
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 19 11:26:49 2015 -0400

    merge

commit 9e7c7271f7ee5f6671ae3dbcc70ffe0ac8d8ecb3
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 19 12:07:50 2015 -0400

    fix [Head]

commit a5ed176e26c7e754881ea8303d3cd45663c89ec8
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 19 12:09:37 2015 -0400

    remove push-list argument

commit 9dcf5e80b71e29f03b87baba9b9f27fbf39e270e
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 19 12:11:23 2015 -0400

    remove shared-seq push-stack

commit 05459f72ccc318d7b2abc855e4135b5af43bdcc6
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Oct 20 17:23:22 2015 -0400

    change altype decl to postfix fashion

commit f8df1fdce3723b5c1997c70f2051af7a1118656b
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Oct 20 17:23:30 2015 -0400

    add TODO

commit 9c611b38721436d09e35ae16910e0c2675f1f119
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Oct 20 17:23:43 2015 -0400

    stash LRM

commit 081a6bc3f89ea783183f36e719d7481e0315e56b
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Oct 22 00:13:18 2015 -0400

    add manual

commit 49f4a15948899a2cf4f006aba4589b77c423277b
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Oct 22 16:52:17 2015 -0400

    hope this commit ends the paper work for a while

commit 4076cf8b28d8885f0049f5199e82519a68cd7760
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Oct 22 21:29:41 2015 -0400

    add new docs

commit 35eb27e784c2b53d145a2e5492acdb66e7589298
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Oct 22 21:32:12 2015 -0400

    add tail recursion and at symbol

commit 215cfb65051be7048acb7172c4eb4a4256e57b87
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Oct 24 20:49:38 2015 -0400

    enhance number literals

commit b5713c0797a1fcd49ffe6c2861df0adc0a22b835
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Oct 25 16:18:12 2015 -0400

    change to waf build system

commit b5d5d66d56bfba08c101231db0514499253d6b1b
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Oct 25 17:40:33 2015 -0400

    restrict float token

commit 089a785c6745ca6ad082687d8e63d337457243ac
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 26 12:00:57 2015 -0400

    add readme

commit cba6266d372f576da854c35c98f0782655262214
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 26 12:01:11 2015 -0400

    change to python3

commit 706d95f32d050b69145ffb321cf7b80c28aba1c2
Merge: 4076cf8 cba6266
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Oct 26 12:02:59 2015 -0400

    Merge pull request #3 from qwert42/tail-recursive
    
    Tail recursive

commit 3e16c66a222f878ce82beb7658ed90d4a97c1549
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 2 22:18:35 2015 -0500

    stash compiler prototype

commit a1f41c30d541332825c1e4653ba3f83633259bc7
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 2 22:19:03 2015 -0500

    stash manual

commit a566c4426da2fd7742df85785778b3142e196371
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 2 22:19:31 2015 -0500

    amend asm manual

commit 224355af65723d395ec5980e1e564ccaac704939
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 2 22:34:22 2015 -0500

    remove name_ref_key

commit d4d29c3bfce61b49326299cef1dbf1b0b5ab66d8
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 3 16:36:32 2015 -0500

    compiler 90%

commit f92a968bef03b61601b695b5bd971ef22cb4fa09
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 3 20:50:42 2015 -0500

    first somewhat working compiler version

commit 5eed46fa4cb3db014cf3670c7008cc286568b3df
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 3 21:34:59 2015 -0500

    add ufint and big int support

commit 5608397e1783fd9e70e6f49e5bd7e25f3d10720a
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 3 21:43:57 2015 -0500

    update manual

commit 504b7dd208f9545fb9b7c425cfbf25c4bdc36fcf
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Nov 4 21:03:37 2015 -0500

    i just cant remember what i did

commit 61c023e02f7c76c7384d13b5ddfd6f6255e123b0
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Nov 4 21:17:27 2015 -0500

    update readme

commit e5323f2f660f6f072a01e37778b50246c8ff2e66
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Nov 5 20:24:57 2015 -0500

    a

commit 7a22edd382e9c1079f01da2aaffb8842f70c8360
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Nov 7 22:32:47 2015 -0500

    fix certain bugs

commit e1e498d298ea09332214d4dea34884d7f1ee2294
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Nov 7 23:04:48 2015 -0500

    resolve certain grammar issues

commit 55e0fc68f47c2b5ba521caac41b1670efeafb664
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 00:47:57 2015 -0500

    resolve some more issues

commit de01a09cd6e1f2743c88b50cb42424f6c6ef19cf
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 01:25:44 2015 -0500

    refine mechanisms about backquotes

commit 8d84f19b79930a783d448414c0dcb6f9d7664fc2
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 01:43:19 2015 -0500

    fix passing wrong inst ctx in g_seq

commit 56e99458c56a5d8122e65f8ea7aa6faaa4a007c3
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 12:37:26 2015 -0500

    fix some backquoted seq issues again

commit 3a77d8c0c9627712509584b201e124e2e6aa8526
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 12:40:03 2015 -0500

    Update cseg.ml

commit 988b7e6df18dc1334b36f36e40cb5be6878173a1
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 12:41:52 2015 -0500

    Update scoping.ml

commit db05d67ce3a053c6317ff39dad1dd0c8ac7795f4
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 12:59:38 2015 -0500

    change tasm to library

commit 9d7f5a2c3109f8e6899add7bd628e63133b2b327
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 13:06:48 2015 -0500

    change tasm to library

commit f37054c18ec1e1be5d579b8c02ef04923a461bbf
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 17:55:31 2015 -0500

    yeehaaaa

commit a7c35dd547dad29bf38c7343d141be408df558ca
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 18:23:55 2015 -0500

    sync instruction modifications

commit 8c65d6f6fa94611fdff8b8811b5ee3b44cbdfc70
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 20:05:53 2015 -0500

    add towel-mode

commit 96349b71f7646d374cac856ddf9d92c4676ca950
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 20:10:22 2015 -0500

    Update ccg.py

commit 1acd486b01fc013848e7c15c5c9a701b13ee93f1
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 20:11:23 2015 -0500

    Update TODO

commit 6bc36f0780b18a3ff2f9ada4a39d6f92a375a896
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 22:51:11 2015 -0500

    Update README.md

commit 47865a17230952ef3c1c4c3e99f76aa53ba08d59
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 23:28:40 2015 -0500

    Update README.md

commit 17152d5e68644c5278a903b3c2bccc573958c6f1
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 8 23:32:46 2015 -0500

    Update README.md

commit 0392e2fbd40d69b5230e34e6655aa238fb1dfdd4
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 9 00:13:59 2015 -0500

    Update README.md

commit d431dd33318ba718fac22fdd0c8311383be2d271
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 9 01:07:13 2015 -0500

    Update README.md

commit 3e5f696d503fb093ef8b8e1d1362af1a66a7e98f
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 9 14:27:27 2015 -0500

    reverse branch instructions

commit ec8d953081fccc88ed647d3c295b9f141772d7a0
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 9 17:42:16 2015 -0500

    change name indices to uint64

commit 78b1a46a0ceaa1f85a302861a520a41853c96c67
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 9 17:50:01 2015 -0500

    change jump pos to uint64

commit 70f94b2f1c4bdbe83e0f17f98776d425ad4cc832
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 10 14:49:51 2015 -0500

    add import and export phrases

commit e1b67b9ee1af813189232f40531411e1ab549b35
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 10 15:28:24 2015 -0500

    add import and export statements

commit 816a470e21d61333394fd544b9af4c5cda40fc62
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 10 15:30:54 2015 -0500

    stash vm changes

commit c9b80646072fc22ee6186648e0bef4deb45716d3
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 10 15:42:03 2015 -0500

    update gitignore

commit 4cf8afa4793b44371dfaa55f7dfb1e0d3c2b912d
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Nov 11 12:35:16 2015 -0500

    add multiline comment

commit d37caf38e5a491084212563bb5d1685e083338e8
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Nov 14 18:27:21 2015 -0500

    add prefect test suite

commit 111dda2c588477f02712f3b15511f79718aeddda
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Nov 14 18:28:36 2015 -0500

    Update README.md

commit 16381dc0e8a54d680953ba135e6511c90bbe505b
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Nov 14 18:29:25 2015 -0500

    Update wscript

commit a01a7f2d912ac871bd5516d51064c589a3d2969a
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 15 13:58:17 2015 -0500

    add .e files gen and import mechanism

commit 91c669dd9392cfaf17fa5f08497e0dae7e147162
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 15 23:11:07 2015 -0500

    hello world!

commit 01edd76fb943f31d4f63d974920da5c21d9cae2d
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 15 23:43:59 2015 -0500

    unquote scanned string

commit 2224d9951370714c0ef34f0cab982d9b1d18b2c6
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 16 00:18:57 2015 -0500

    amend prefect test suite

commit 819b6f63a34f0f360a713892433eea3fc623f0b5
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 16 00:26:37 2015 -0500

    amend prefect test suite

commit e3d94dc14eadd778a9c500866cfdb59d71d0423e
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 16 02:21:09 2015 -0500

    add branch instructions

commit 6a78a47f2d989611ef5c54baf418134c9842230b
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 16 15:19:18 2015 -0500

    (tail recursive) gcd working

commit bc2472f37f0eb661ffb9e012f24530e1ca97a5af
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 16 15:21:11 2015 -0500

    amend test description

commit 492a06a87b7e05316bd39d01e70d2df149fcb571
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 16 16:54:44 2015 -0500

    merge all the orts

commit 1ffcd2b5aaef9e68b2ad2af2ae209afbef119427
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 17 01:37:09 2015 -0500

    change to ccg.rb

commit e77b6a44673fb0bfb219135afdf3499c08d7ba64
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 17 12:38:04 2015 -0500

    add idle

commit cd3683c754b61939afd84d0c64bf7e7b67ba6e22
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 17 12:39:56 2015 -0500

    add pop

commit f9678e005a9db253cdbbf196be0b5e3c962b7d60
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 17 12:40:38 2015 -0500

    add idle 2

commit 20a65ee00228b9c244c14bf98475121a046a4181
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 17 12:41:13 2015 -0500

    fix branching instruction label args

commit 132a1dd873418be434f00887d87f175d4ab47e19
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 17 12:42:07 2015 -0500

    dont remember

commit 79f36dfbfebe9dcf4806845d0fcc082c9e215c8e
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 17 12:42:23 2015 -0500

    update readme

commit 3b37049e0cf3992fb89130df6a70f9024700cf4f
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 17 12:42:34 2015 -0500

    add sqrt example

commit 360cd649f1bbb604b500df51d2cbbb83411c065b
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 17 12:49:58 2015 -0500

    change std naming standard

commit 0087e38f969c49d3562cebf463ed1865f5be3c05
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 17 15:31:19 2015 -0500

    prepare for generalized arithmetics

commit c33f631c999cbe8749996323a8669c092eec8dca
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 17 15:43:50 2015 -0500

    fix import mechanism

commit bee96ae57f55adec4a03dc86548d206db1fb8bc4
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Nov 17 20:37:32 2015 -0500

    add std_gen

commit 1bbb971cdc5d160b00a948ae2cca5e5554b36633
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Nov 21 19:17:16 2015 -0500

    add function backquote

commit 98c087aea73d1b95c49aefc3a32eb93763f84645
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Nov 21 21:51:50 2015 -0500

    add push-lit

commit a9e0c4b9c33b26e2d1b81ba1b0599476429531d8
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Nov 21 21:53:13 2015 -0500

    add partial fun-arg

commit 138f0cb5a1f80217e993d75cf5706e897023c300
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sat Nov 21 21:53:37 2015 -0500

    add stacked list/tuple creation

commit 57cd0428ff4646e34e22df1845e039165c8dec9c
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 23 11:35:24 2015 -0500

    add closure set to fun_t, remove them from funpool

commit 1de084738b6c5ad2e2482f7c49ae72a1f08bf818
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 23 11:35:58 2015 -0500

    finish std-gen script

commit 8131e4007ddc62a335af81a1810059336cfa2b3f
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 23 11:36:31 2015 -0500

    recover to *-tuple and *-list insts

commit a78410b0bde4ade7854b3f06e813985a5692bc06
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 23 11:36:53 2015 -0500

    fix ref number to BQFun

commit f7cefd74055547cda9abfefeef7de5c18eeab4af
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 23 11:37:25 2015 -0500

    add VAtom to tasm_ast.mli

commit 383bdc857a4133f682efb32745ffced29bd969d1
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 23 12:19:23 2015 -0500

    fix atom stringifying

commit 4e0c9f4760998268ce8d6918af1b33c84d3b4218
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 23 12:19:57 2015 -0500

    fix true and false atom_repr

commit cc117db2422032646dd042aad675f34c5aafc643
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 23 12:20:08 2015 -0500

    fix warnings

commit b215176231833466c05d183eba1b644d608e3042
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 23 12:52:04 2015 -0500

    add ift-f and import tests

commit deadfc7d3ea8fd3d36c75128268beddfc614c1e5
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 23 13:14:17 2015 -0500

    add phony (stack bottom indicator)

commit 704eb448875515ef6fc6c7cb2bf571a8cc8a8f3f
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 23 15:06:16 2015 -0500

    add phony

commit afdb02c69f629c80c3add57589fcd7fde1c6f32b
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Nov 25 14:51:14 2015 -0500

    stash changes

commit 5b1947dea3e5e6501d14631a622624e31291972c
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Nov 26 02:26:30 2015 -0500

    get rid of some warnings

commit dd83c647ede6424a27e364967174be0746f69bf8
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Nov 26 02:27:24 2015 -0500

    refactor

commit 01e1ab3a73a19385065a128954e4b955cf9a2b40
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Nov 26 02:28:47 2015 -0500

    cope with new function grammar

commit 94c2aeb06d50f904710c1be75a05784ed3bfc12a
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 00:03:34 2015 -0500

    remove hjne

commit b8db2dd469e0a785e3417fec2b146bc8be8ed2cc
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 00:04:55 2015 -0500

    refactor vm

commit f7dbbbffb6aac8dc492dddd33994c605d0ac7ea5
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 00:05:49 2015 -0500

    add new highlighting

commit 305c0b2bef2317ca06a92c8351ae0b22b470b109
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 16:05:09 2015 -0500

    resolve regression

commit 39cb55cd44d8995ffeef795247e624b99399c3f5
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 16:06:04 2015 -0500

    add !rev built-in

commit 354ef3a31340eb1f66b3417665a34a5fa15f46f3
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 16:35:08 2015 -0500

    refine seq code generation

commit e347db7536184ffed753ff91769377ca893c0592
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 16:35:40 2015 -0500

    redef reverse and pack arity

commit 905648856ca365c17c3609432686aba90c0c9e14
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 18:21:22 2015 -0500

    remove equ instructions

commit 19d4ca85e302021a926ca275a918727eb996ce7c
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 18:21:54 2015 -0500

    add abs module id to avoid import collision

commit cfc2e9b603514232ff5374b7b68eee1fbcd09235
Merge: 19d4ca8 704eb44
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 18:25:40 2015 -0500

    merge to master

commit 97f57a4385309d31608445079afe0e6c82d1a785
Merge: 704eb44 cfc2e9b
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 18:26:08 2015 -0500

    Merge branch 'ortless'

commit 8a90269f19e019129abe57ae095bd3f32fa7cac3
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 18:41:14 2015 -0500

    Update README.md

commit 3155431d8637e3a40a0a670fb0fe031a62435799
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 21:46:42 2015 -0500

    fix warning

commit c13b79ce59bbb822c073a113c7ce562ea3674399
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 21:47:30 2015 -0500

    remove about 20 instructions

commit 8a4c3b944fdc16e5f20c4fae86744ae28686ce65
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 22:45:14 2015 -0500

    add push-list etc.

commit bf1d398fb3026e497a344051e332d5226c421868
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Nov 29 22:45:27 2015 -0500

    add partial fun test

commit 6f362d06f4101a4e777eff42f83545a58335a984
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 30 13:04:38 2015 -0500

    add invoke inst

commit bff1a4601b419bead8c7a4b4d531dc48c5605ded
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 30 13:05:09 2015 -0500

    remove OVLNil and OVTNil

commit 051116e3a287eaaf833a94455a45f250e08c8e9b
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 30 20:23:41 2015 -0500

    rename make-fun and push-fun

commit b80d4cc434f8562a9826d9c8f30234c4d6651369
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 30 20:44:18 2015 -0500

    fix potential partial fun arg issue

commit 21a6c5c79315e80d09bc7f351e239db6c34aec3e
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 30 20:54:21 2015 -0500

    rm unused file

commit 3f1ff9e3a42b2177a00e8500e19b8b90cd9298a2
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 30 21:36:07 2015 -0500

    remove period terminator (really no point in this)

commit b2364f1e4cd6fc5a71492f97c0d3b693578c6095
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Nov 30 21:36:59 2015 -0500

    add list operations

commit 2fa2ef3373e982f8220281a7f660d917a07b2be1
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Dec 1 00:08:27 2015 -0500

    add type sig to std lib

commit 8942b9f92cdc5b3673cc817ba2a5c4051f7e26fe
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Dec 1 14:21:19 2015 -0500

    add cons

commit c145ac9fbc78400a337e8d16a120e1b549651bae
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Dec 1 14:22:38 2015 -0500

    hide std lib funs

commit 6b500686fa76119eacbaaf189b59e3e85f0d3f36
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Dec 1 14:23:01 2015 -0500

    handle compile failure and exec failure

commit bb6b840307475a9b774bc715bcba4fc008565f56
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Dec 1 15:57:01 2015 -0500

    fix bind push-name

commit 19e96d2643bb64fec3563e498259a2dec2aa7a23
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Dec 1 15:57:47 2015 -0500

    get rid of dot at the end of .e files

commit f8eee5e5109b4f29f0d48f54eedb71de082a9540
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Dec 1 15:59:26 2015 -0500

    add new std lib, but broke imp import

commit 781602e1f1ce374f30e357fc9f85f20265f2e7e7
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Dec 1 17:23:17 2015 -0500

    fix imp import by counting name ids

commit 1ca7baef5176b94e2cfc4932a1d37474e2ed6d78
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 14:26:34 2015 -0500

    fix relative importing and name resolving

commit fe762e4a3c3d928b0d5a03fabdab1e6298d1519c
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 14:28:13 2015 -0500

    change to rel import

commit 529325a262fee81d559887bcc52fb0976354c779
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 14:28:31 2015 -0500

    add mod and equ

commit c834997d2e65d0e49882ce725a302e8d9397c35a
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 14:29:14 2015 -0500

    add functional library fun and test

commit b714c0dccb8f86e0ee80cdb1325b6021dd0f7709
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 14:56:19 2015 -0500

    refine EQU, add :filter

commit 4699eaa9ddbbec794aa421732baa23cff5e9ed36
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 15:13:24 2015 -0500

    add travis

commit 2916cc76f6437b0bdace50f45a41e746d9081ef5
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 15:18:30 2015 -0500

    set sudo: true

commit 7c4c883c266059c559a1305d0e00a9b5f0ed9196
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 15:21:59 2015 -0500

    change to source install opam

commit dc3f120def68622d9b3b77f0665ad20f6e1381a0
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 15:28:34 2015 -0500

    change to source install opam

commit 389ee7fd9794d74600235e9867c9d10bec4f52d9
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 15:31:21 2015 -0500

    .

commit 05c1de2f120cb7a07f5f74cb446737cd745b196a
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 15:33:42 2015 -0500

    fix typo

commit 4328355ae6dcb6cb5f3ee6eb10d54f2d008d4b98
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 15:39:59 2015 -0500

    fix ruby install

commit d91d288efdc6c9b279435f4f20ce3d3ad8112f2b
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 19:50:12 2015 -0500

    fix seq label issues

commit 548173944a670593fe3058e71e5e746e04a18a70
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 19:50:48 2015 -0500

    add /flip and /foldr

commit b282f4f673f8b3768cd3d4f06fb1ec997d0ebbc7
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 19:57:21 2015 -0500

    fix recursive fun args

commit 873b98a6ee548c645040d83627743951dd182819
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 20:05:03 2015 -0500

    update comment

commit 516174a90141904bb3b5b8860b0623d5fd9fa1f9
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 20:24:40 2015 -0500

    add lambda token

commit 5ca39838852d2044bf294e440e1282257290a678
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 21:34:06 2015 -0500

    fix branching insts

commit cec55ebbd89eb147eef9f74bddd1b61d6d4bcf1f
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 21:36:48 2015 -0500

    fix phony mechanism

commit 13110e8f8f0d1563cfc3eda30e9da82613fecf9f
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 22:16:17 2015 -0500

    add aliases to list functions

commit 901df6d3ac29e9299b0aa207900501de25ffbfa5
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 23:23:08 2015 -0500

    .

commit d3a6dcaae2018e114d1e83fdb059fe3c040f8d25
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 2 23:32:07 2015 -0500

    add .gitattributes

commit 3ebcb3cda7a7f217edc493c22e30b26cc6417862
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Dec 3 14:41:12 2015 -0500

    fix rel import name resolving

commit 652e9c30583ce174d703de65dd1517942641c9b8
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Dec 3 14:45:00 2015 -0500

    support test suppression by prefixing __

commit 85242c0892e452c551b66aa69d86d9bc2163fc86
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Dec 3 14:46:35 2015 -0500

    add built-in and some stack insts

commit bfe25336ff1e4cdfab02c03009bd2332d1c6769d
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Dec 3 19:26:25 2015 -0500

    fix closure binding

commit a6c30f7ff740c61bafb78ee419815ef6f82e394e
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Dec 3 19:55:10 2015 -0500

    implement ext module mechanism

commit 5646e45ae7fb541b07376e7a19b63bb8a6234c1e
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Dec 3 20:04:16 2015 -0500

    add new gitignore entries

commit 156b5c6a0c0faf619a6d74b6dfbbfdda84d94ae9
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Dec 3 21:39:34 2015 -0500

    add something new

commit 00d86e6fa1a8f7883c750cc04cbfb3f5020cd159
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Dec 3 21:45:41 2015 -0500

    Update README.md

commit b95f09835365db65c1be98bbe3ba63af1b0e9207
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Dec 3 23:51:32 2015 -0500

    fix je and hje, remove built-in

commit db7d9c87ec4d7b96df096c27f1c53e0d334b5d28
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Dec 4 00:33:13 2015 -0500

    amend towel asm defs

commit b444ef28d99c1da86083941a12869178c609cd97
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Dec 4 00:55:19 2015 -0500

    add ext howto

commit ce8a6feb02f26f3e4164e29ffb8e2427f96407be
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Dec 4 00:56:25 2015 -0500

    remove sh files

commit a09fd42d932eae637b2b6026379ea47b17f84d8c
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Dec 4 01:00:16 2015 -0500

    refine prefect

commit b8cf11a7352557048dae5e8dc8bd02c4c8921204
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Dec 4 01:02:04 2015 -0500

    update readme

commit 41a86a44f4b1426495a440342538c6eb15f7aa2f
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Dec 4 03:23:54 2015 -0500

    update towel asm manual

commit 87293913668a22375078420e2f1c9078e2a5cf46
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Dec 4 03:24:23 2015 -0500

    hello world tk!

commit f735768503b8f6b6ca67a0702b1fbd23fc0bc244
Merge: 2fa2ef3 8729391
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Dec 4 03:24:43 2015 -0500

    Merge pull request #6 from qwert42/dynatowel
    
    Dynatowel!

commit 507bdd554e4f80e10d7471780be633c934b893be
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Dec 4 03:27:56 2015 -0500

    Update README.md

commit 7f9244d7c81efc7b729fdf08d31a72cdbfca9833
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Dec 4 03:28:16 2015 -0500

    Update README.md

commit 163a5f2835bac4ec9c514b04ef6c87052e36e9d5
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Dec 4 03:29:09 2015 -0500

    update towel asm manual

commit 1ad889deaa22b89ccf5f1e98f9f9368c0f090043
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Dec 4 12:40:49 2015 -0500

    Update std_gen.rb

commit af387a8e6b80ecee89a285a97846f4f6319f72ce
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Dec 4 13:33:19 2015 -0500

    change ~pred to ?pred

commit 38586b2f52f0a682eaad359ed3a1b9a4b577b499
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Dec 4 13:34:05 2015 -0500

    update TODO

commit ac954d940d2d7e414ad8f86384194f773d854e2c
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Fri Dec 4 22:57:54 2015 -0500

    make some amend

commit da1de6834be64c68ea7f7d003dfa16a1a5a43065
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Dec 6 01:09:12 2015 -0500

    add bytecode representation

commit d4f37a6da1f1e1bd99700d100cbdf6fa10071d1e
Merge: 38586b2 da1de68
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Dec 6 01:12:16 2015 -0500

    Merge pull request #7 from qwert42/bytetowel
    
    Bytetowel

commit 7009ae603c7be6d59af1a7090951f42f4d1007cc
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Dec 6 01:14:44 2015 -0500

    lose unnecessary dep

commit 38f75bf930408e8c9ff50bc7508365a45ef8bbfb
Merge: d4f37a6 7009ae6
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Dec 6 01:15:18 2015 -0500

    Merge pull request #8 from qwert42/bytetowel
    
    lose unnecessary dep

commit 0bfc5a5172ad7d638ed412afb463621487fb98ce
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Dec 6 10:31:48 2015 -0500

    remove idle and phony from grammar, add them to .w

commit 5305ba6d176d83e90b30e314ea6cdb3d4b741902
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Dec 6 13:44:32 2015 -0500

    fix tk bytecode parsing error

commit 50777b2378654ea411b4c27235d4d01a01af62f2
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Sun Dec 6 17:38:50 2015 -0500

    refactor name resolving

commit 14112bb342ce799fc41ed558a3fb8db63cebaa2a
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Dec 7 00:58:28 2015 -0500

    add install instruction, quicksort still fails

commit f66076f650d698ab796ed3b60272c87c14c24481
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Dec 7 00:58:57 2015 -0500

    opt std stack usage

commit fb4c2794d20845cb825e331058b5a8dfd0ce3bbd
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Dec 7 00:59:08 2015 -0500

    add *** debug instruction

commit 460551dc02d3c88aa45879ffd1e3f5aeddd6c314
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Dec 7 00:59:50 2015 -0500

    add tests; quicksort.t still fails

commit 9f2388ba1fe117347fe6482ca5a517b24e55fc12
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Dec 7 01:00:47 2015 -0500

    add one more test

commit adb1d3c7520d7ef4fb066ef9cb92d2493837986a
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Dec 7 12:49:49 2015 -0500

    fix scope overflow

commit ec64e870e210f65d5cdf0e151648bc8e3630a503
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Dec 7 13:14:32 2015 -0500

    add more wrappers for .w

commit 9092e09ff9b7b8ed2fc75b150a736ae9df45f1b8
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Mon Dec 7 23:16:04 2015 -0500

    add type reflection, opt name resolve

commit 1fc75f2ac775b26c260e2ff9f84308ddd59f48cb
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Dec 8 01:15:09 2015 -0500

    remove all the compiler-side type decls

commit b19997c08908aabde7940a5ddc0d68657539b505
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Dec 8 19:02:41 2015 -0500

    change list inflation mechanism

commit d4df4251fc4f2c2b7a12727ca389795b7a96180f
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Dec 8 19:13:52 2015 -0500

    be conservative about put_val

commit fa8caf0c0b04e27cae92c3513f2b67d10291d67c
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Tue Dec 8 23:56:30 2015 -0500

    add tuple-at

commit 1eaf57d5e94b5e7924258b267fc820b4dc264d81
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Wed Dec 9 15:47:10 2015 -0500

    revise manual

commit dbbe42bcfd500f2f199cc6154d13c99670a5e09d
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Dec 10 02:17:23 2015 -0500

    modify import instruction format

commit b2910cbb2828487174e59efba7771c9e72f53544
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Dec 10 02:17:39 2015 -0500

    add report

commit 8c8234d4d286ff65c7294121944c28c35e4b7555
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Dec 10 11:38:40 2015 -0500

    change copy to ref in closure

commit 6999be5b9484309ff2a608483976a4079a965d57
Author: Zihang Chen <chsc4698@gmail.com>
Date:   Thu Dec 10 15:16:26 2015 -0500

    add more tests and texts
\end{verbatim}

\chapter{Full Code Listing}

\input{../play/xxx.tex}

\end{appendices}

\end{document}
