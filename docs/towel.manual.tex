\documentclass{book}

\usepackage[left=1in, right=1in, top=1in, bottom=1in]{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{mdframed}
\usepackage{showexpl}
\usepackage[normalem]{ulem}

\title{Towel Reference Manual}
\author{Zihang Chen (zc2324) Baochan Zheng (bz2269) Guanlin Chen (gc2666)}

\mdfdefinestyle{detail}{%
rightline=true,innerleftmargin=10,innerrightmargin=10,
frametitle={Implementation Detail},
frametitlerule=true,frametitlerulecolor=white,
frametitlebackgroundcolor=cyan,
frametitlerulewidth=2pt}

\mdfdefinestyle{hint}{%
rightline=true,innerleftmargin=10,innerrightmargin=10,
frametitle={Hint},
frametitlerule=true,frametitlerulecolor=white,
frametitlebackgroundcolor=yellow,
frametitlerulewidth=2pt}

\mdfdefinestyle{example}{%
rightline=true,innerleftmargin=10,innerrightmargin=10,
frametitle={Example},
frametitlerule=true,frametitlerulecolor=white,
frametitlebackgroundcolor=green,
frametitlerulewidth=2pt}

\mdfdefinestyle{example}{%
rightline=true,innerleftmargin=10,innerrightmargin=10,
frametitle={Example},
frametitlerule=true,frametitlerulecolor=white,
frametitlebackgroundcolor=green,
frametitlerulewidth=2pt}

\mdfdefinestyle{warning}{%
rightline=true,innerleftmargin=10,innerrightmargin=10,
frametitle={Be warned!!},
frametitlerule=true,frametitlerulecolor=white,
frametitlebackgroundcolor=red,
frametitlerulewidth=2pt}

\newcommand{\mstd}[1]{\texttt{#1\textbackslash Std}}
\newcommand{\mtilde}[1]{\textasciitilde}

\newcommand{\marg}[1]{\texttt{\mtilde ~#1}}
\newcommand{\mla}[0]{~$\leftarrow$ ~}
\newcommand{\arithstd}[1]{\marg{1} \mla \marg{2} \mla \mstd{#1}}

\begin{document}
\maketitle

\vspace{10cm}
\begin{figure}
\centerline{\includegraphics[scale=0.75]{images.jpg}}
\end{figure}
\newpage

\tableofcontents

\chapter{Language Overview}\label{chap:overview}

Towel is a general-purpose, stack-based, postfix-syntaxed, dynamically strong-typed, functional, language targeted at the Towel Virtual Machine.

\section{General-purpose}

Towel is designed with the universe in mind. So the syntax of it is expressive, yet concise.

\sout{Oh, by the way, it is also the language used by Deep Thought when it computed the Answer to The Ultimate Question of Life, the Universe, and Everything to be 42.}

\section[Stack-based]{Stack-based\footnote{It's not only stack-based, it's actually stack-stack-based. See also \autoref{sec:basics}.}}

Although stack-based programs are hard to reason about, it's really efficient and powerful to use once you get the gist of it. It's also very simple to implement.

\section{Postfix-syntaxed}

The relationship between postfix syntax and stacks is just like a towel to a hitchhiker, so why not?

\section{Dynamically Strong-typed}

This means that Towel maintains types at runtime with no implicit type castings whatsoever, the compiler does not do type checking. However, it does scope analysis for every source code.

\section{Functional}

Once you have full-fledged functional framework, you have the whole world. For example, Church booleans, Church numbers, etc. Or more realistic, you can use functions to emulate records, or even object-oriented programming!

\section{Towel Virtual Machine}

Why a virtual machine? Because we think this is the most portable and easy way to do a whole new language.\footnote{The thing is, you make it run first, then you optimize it.}

\chapter{Lexical Elements}\label{chap:grammar}
\section{Keywords}

Keywords in the Towel programming language is as follows:
\begin{verbatim}
if>=0 if>0 if<=0 if<0 if~0 if=0 ift iff ife ifne
match fun bind type also then export import ,\
\end{verbatim}

\section{Punctuations}

Punctuations used in the Towel programming language are as follows:

\begin{itemize}
\item Whitespace characters are simply ignored.
\item These characters have special meanings in the Towel programming language: \texttt{` ' `` , ; ( ) [ ] { } \char`\\ ~  @ EOF}. This means that you cannot use these characters in names and atoms. \footnote{In other words, you can use any other punctuation characters in names and atoms.}
\item Any unprintable character is reserved and won't be used.
\end{itemize}

\section{Names}

Names are used for naming (or to be more precise, referencing to) values. Valid names should not start with reserved punctuations, lowercased letters, and numbers.

More formally,
\begin{verbatim}
  unprintables ::= [all the unprintable ASCII characters]
  whitespaces ::= ['\n' '\t' ' ' '\r']
  reserved_punct ::= ['`' ''' '"' ',' ';' '\' '@' 
                      '(' ')' '[' ']' '{' '}' whitespaces unprintables]
  valid_punct ::= ['!' '~' '#' '$' '%' '^' '&' '*' '-' '_' '+' '=' '|'
                   ':' '<' '>' '?' '/']
  BQUOTE ::= '`'
  SQUOTE ::= '''
  DQUOTE ::= '"'
  COMMA ::= ','
  SEMICOLON ::= ';'
  PERIOD ::= '.'
  SLASH ::= '\'
  AT ::= '@'
  LPAREN ::= '('
  RPAREN ::= ')'
  LBRACKET ::= '['
  RBRACKET ::= ']'
  LBRACE ::= '{'
  RBRACE ::= '}'

  digit ::= ['0'-'9']
  hexdigit ::= ['0'-'9' 'a'-'f' 'A'-'F']
  bindigit ::= ['0'-'1']
  lc_chars ::= ['a'-'z']
  NAME ::= [^ '-' reserved_punct digit lc_chars] [^ reserved_punct]*
\end{verbatim}

You can also resolve names in other namespaces (what we call \textit{modules} in Towel) by concatenating them with a backslash.

\begin{mdframed}[style=example]
If you would like to access the name \texttt{+} in module \texttt{Std}, which is in module \texttt{MyStdlib}, you can write:

\begin{verbatim}
+\Std\MyStdlib
\end{verbatim}

\end{mdframed}

\section{Literals}

Most easy-to-use languages support a wide variety of literals (Python is a good example and Java is not). The Towel programming language supports literals for atoms, integers (fixed, unsigned fixed, big), floats, strings, lists and tuples. They are defined as follows (rule for list literals will be revealed later):
\begin{verbatim}
  ATOM ::= lc_chars [^ reserved_punct]*

  signed ::= ['+' '-']
  fint_body ::= (("0d"? digit+) | ("0x" hexdigit+) | ("0b" bindigit+))
  FINT ::= signed? fint_body
  INT ::= signed? digit+ ['L' 'l']
  UFINT ::= '+'? fint_body ['U' 'u']

  dot ::= '.'
  int ::= digit+
  frac ::= digit+
  exp = 'e' signed? int
  dot_float = ((dot frac) | (int dot frac)) exp?
  exp_float = int (dot frac)? exp
  FLOAT ::= signed? (dot_float | exp_float)

  string_char ::= [^ '\' ''']
  string_esc_seq ::= '\' string_char
  string_item ::= string_char | string_esc_seq
  STRING ::= ''' string_item* '''
  (Rules for strings is from the lexical parsing section of the Python
   language reference manual.)
\end{verbatim}

\begin{mdframed}[style=detail]
Because positive (or negative) numbers, ``+1.'' for example, also uses the plus punctuation, \texttt{NAME} is actually more complicated than what's written above:
\begin{verbatim}
  NAME ::= valid_upper_char common_valid_char*
         | '+' common_valid_char_no_digits?
         | '+' common_valid_char_no_digits common_valid_char*
         | '-' common_valid_char_no_digits?
         | '-' common_valid_char_no_digits common_valid_char*
\end{verbatim}
\end{mdframed}

\section{Comments}

Comments are defined as follows:
\begin{verbatim}
  __COMMENTS ::= '"' [^ '"']* '"'
\end{verbatim}

\section{Lexical Error}

When the scanner encounters any other character not mentioned above, it will raise a \texttt{LexicalError} exception.

\chapter{Data Types}
\label{chap:data-types}

This chapter covers the basics on types in Towel. It worth mentioning here that all the values of whatever types of Towel is immutable.

\section{Built-in Types}

Towel provides to the user the following primitive built-in types:
\begin{itemize}
\item Atom
\item Fixed integer or, FixedInt
\item Unsigned fixed integer or, UFixedInt
\item Big integer or, Int
\item String
\item Float
\item List
\item Tuple
\end{itemize}

\subsection{Functions}

Functions are one of the most important kind of values in Towel. They can be returned as values, passed as arguments, and evaluated as regular functions. This kind of feature is often called as \textit{functions as first-class citizens}. A function gets its argument from caller's data stack (often the data stack beneath it, or the same stack if it's a tail recursive call), and returns the TOS on its data stack.

\begin{mdframed}[style=hint]
Although it is not recommended, you can always use the \mstd{!!pack} routine\footnote{A routine in Towel is a function with side-effects (or stack-effects).} to pack multiple values in the callee and \mstd{!!unpack} them in the caller to achieve multiple return values.
\end{mdframed}

\subsection{Atoms}

Atoms are special names uniquely bound to integer constants. But they are not comparable to integers, nor can they be applied to numeric operations. It's also meaningless to compare between two atoms.

Towel predefines \texttt{false} and \texttt{true} as boolean atoms.

\begin{mdframed}[style=detail]
Although, they are not comparable to integers, they can be tested against each other to see if they are the same. The earlier the atom appears in code, the smaller the integer constants it gets.
\end{mdframed}

\subsection{\texttt{(U)FixedInt}s, \texttt{Int}s, \texttt{Float}s}

(Unsigned) fixed integers and floats are 64bit integers and floats. \texttt{Int}s are signed integers of arbitrary precision (like those \texttt{int}s in Python). These types are said to be subclass of the class \texttt{Number} (only conceptually), which is to say all these types are supported by basic arithmetic operations. However, bitwise operations will only take (\texttt{U})\texttt{FixedInt}s as arguments.

\subsection{Strings}

String items are surrounded by single quote, rather than double quote.\footnote{Because you don't have to hit the \textit{shift} key when inputing single quotes. Same goes for brackets.}

\subsection{Lists and Tuples}

Lists and tuples are enumerable types in Towel.

Lists are accepted by list-related functions, such as \mstd{\#hd}, \mstd{\#tl}, \mstd{?\#} (list emptiness test). However, note that only lists are supported by the \mstd{\#cons} operation. When you \mstd{\#cons} to a tuple, Towel Virtual Machine will blow up.

Tuples are accepted by \mstd{\#tn} to access specific element of them. They can also be tested emptiness with \mstd{?\#}.

\section{Conversion between Types}

Most of the operations can only deal with homogeneous data types. For example, addition can only happen between two fixed integers, or two unsigned fixed integers, or big integers, etc. A addition between a float and an integer will result in error.

If you really would like to add a float to an integer, either use the built-in function \mstd{\mtilde ~float} to convert the integer into a float, or use \mstd{\mtilde  ~int} to convert the float into an integer.

\section{Runtime Type Reflection}

You can use the built-in function \mstd{\string^?} to get the type of TOS. The returned type is a built-in value that represents types. Type values can be test against each other for equality with \mstd{\string=}.

\chapter{And Now for Something Completely Different...}
\label{chap:forms}

\section{Program Structure}\label{sec:basics}

A Towel program consists of one or multiple so-called \textbf{words}.

When encountered multiple words, they are always evaluated one by one in the order they appear. Although most of the times, Towel remains in a postfix fashion, but for the sake of convenience, some parts of the grammar is of prefix or infix style (e.g. the bind form and namespaced name invocation).

A word, can be one of the following:
\begin{itemize}
\item literal
\item name
\item sequence
\item backquote
\item \texttt{if} forms
\item function form
\item bind form
\item import and export form
\end{itemize}

You should also know that the computational model Towel uses is based on stacks, or to put it more precisely, stack of stacks. That is to say, when you invoke a function, a new stack in created for that particular function, and after it returns the new stack gets destroyed. This avoids potential corruption of only a single stack.

\section{Rules for Evaluation}

When you reference to a word, Towel does the following:
\begin{itemize}
\item For literals, it pushes back them directly;
\item For a backqoute, it pushes back whatever is quoted (i.e. without evaluating);
\item For a function, it creates a new stack, gets whatever required arguments to it from caller's stack, does the computation, pushes back the TOS of its own stack to caller's stack (this is called in Towel ``returning a value'');
\item For a sequence, it creates a new function out of the body of the sequence and evaluates that function;
\item For a name, it looks up the value it references to, evaluates that value and pushes back the evaluated value.
\item For \texttt{if} forms, test against the TOS and evaluate the word in respective branch;
\item For bind-then form, it pushes a new scope, evaluates the values on stack that get bound (both \texttt{bind} clause and \texttt{also} clause) and binds the values evaluated to the names, then it evaluates the \texttt{then} clause within current scope. Finally it pops the scope.
\end{itemize}

\section{Rules for Scoping}

Only two forms in Towel can create a new scope: the function form and the \texttt{bind-then} form. This means that a scope is created when entering a function, or a \texttt{bind-then} form, and implies that a scope is destroyed when exiting a function, or a \texttt{bind-then} form.

A name is only referenceable within the scope it is bound, plus the child scopes of that scope. For closures, the captured names are poured into the function's scope by default.

\section{Literal}

A literal is a literal value whose type is of the data types we have talked about in \autoref{chap:data-types}.

\subsection{Atoms}

You can create atoms by writing any lowercased letter followed by arbitrary length of characters that are not reserved punctuations and keywords.

Atoms are unique across the entire program. Because atoms are assigned with a unique unsigned 64-bit integer, so you can have no more than $2^{64}$ of them in your program.

\begin{mdframed}[style=detail]
  Boolean type is implemented as atoms. \mstd{:and}, \mstd{:or}, \mstd{:not} work for integers as well as booleans.
\end{mdframed}

\subsection{Numbers and Strings}

You can create number and string literals by writing like this:
\begin{mdframed}[style=example]
\begin{verbatim}
  1 -1 2 -3 5 -8 13 -21
  +4242424242424242424242424242424242424242424242424242424242L
  -3141592653589793238462643383279l
  3U +0x4579u 0b11101 0d1234
  1.1e1 -0.1 'don\'t panic'
\end{verbatim}
\end{mdframed}
\subsection{Lists}

When creating a list literal, you must write a list of words separated with spaces in a pair of brackets, like the following code:
\begin{mdframed}[style=example]
\begin{verbatim}
  [arthur-dent ford-prefect betelgeuse]
  [Spam Spam Spam]
  [Spam ifne (More Spam)`, (Less Spam)`] (valid but bad example)
\end{verbatim}
\end{mdframed}

\begin{mdframed}[style=warning]

Although you can safely write list literals with names, and literals (integers, atoms, or even list), but because of Towel's stack-based nature, complicated words in a list literal may not turn out to be what you want.

When the Towel compiler compiles a list literal into instructions, it first generates a pair of instructions called \texttt{push-lnil}, \texttt{end-list}. Then it compiles the words being the content of the list literal, and put the generated code between that pair of instructions. But be warned that, when entering the \texttt{push-lnil} and \texttt{end-list} pair, the target of most of the pushing actions will be come the newly pushed list, rather than the data stack. For example,

\begin{verbatim}
  push-lnil
  push-lit 1u
  push-lit 2a
  push-lit 3l
  end-list
\end{verbatim}

will result in \texttt{[1 2 3]}. And

\begin{verbatim}
  push-lnil
  push-lit 1u
  push-lnil
  push-lit 2a
  push-lnil
  push-lit 3l
  end-list
  end-list
  end-list
\end{verbatim}

will result in \texttt{[1 [2 [3]]]}. Just like what we expected, right?

But consider the following,

\begin{verbatim}
  (2 3 [1 2 +] !println)
\end{verbatim}

This is syntactically correct Towel, but the problem is that it tries to evaluate a function within the environment of creating a list. The user might expect the output being \texttt{[3]} but that not the case: before the name \texttt{+}, the stack is like the following,

\begin{verbatim}
  {| 2 3 [1 2 |}
\end{verbatim}

when the addition function tries to grab its arguments, it first pop the unfinished \texttt{[1 2} as its argument, which is incorrect already. And it then gets its second argument from the stack, which is obviously 3.

You should also be very cautious with

\begin{verbatim}
  (1 2 [3 if>0 +`, -`])
\end{verbatim}

This \texttt{if>0} is tested against the TOS, which is the unfinished list \texttt{[3}!

So in general, never ever put complicated words in a list literal. If you are really forced to do so, enclose the word in a sequence (parentheses).
\end{mdframed}

\subsection{Tuples}

Tuples are fixed length lists, this means that you cannot CDR from them, nor CONSing to them. Create tuples like this:
\begin{mdframed}[style=example]
\begin{verbatim}
  [\ arthur-dent ford-prefect betelgeuse] "a 3-tuple of type PT_Tuple-3"
  [\] "a 0-tuple of type PT_Tuple-0"
\end{verbatim}
\end{mdframed}
\section{Sequence}

Sequences are short-hand forms for creating anonymous functions with no arguments. You can create a sequence by writing the sequence body between a pair of parentheses.

Towel also provides another kind of sequences, the shared sequences. This kind of sequences share the same context (such as stack and scope) with the caller. When creating such sequences, you add an at symbol right after the left parenthesis.

\begin{mdframed}[style=example]
\begin{verbatim}
  ((A B - if>0 1, 0) (A B + if<0 2, 3) :and) "non-shared regular sequences"
  (A B - (@ if>0, 1, 0) !println) "prints 1 or 0"
\end{verbatim}
\end{mdframed}
You may want to create a shared sequence when defining tail-recursive functions, otherwise, you lose the advantage of not stacking up contexts.

\begin{mdframed}[style=hint]
Just for your information, the Towel compiler automatically strips off the creation of certain unnecessary sequences for performance reasons. For example, the following sequences will be optimized out.

\begin{verbatim}
  bind THE-ANSWER 42
  then (THE-ANSWER !println)

  42 if>0 ('The answer is greater than void.' !println),
    ('The answer is less than void.' !println)
\end{verbatim}

The appearances of the sequences above are simply only of syntactical reasons, namely, to avoid ambiguity of the grammar. They can be safely removed semantically.

See \autoref{sec:switches} for more details.
\end{mdframed}

\section{Backquote}

Towel evaluates and pushes everything it encounters, you can use backquotes the values to prevent Towel from evaluating them so that Towel pushes them directly onto the data stack. Backquotes are created by appending a backquote to the words you want to backquote.

You can backquote only limit types of words:
\begin{itemize}
\item literals; Towel pushes the literal back immediately
\item names; Towel pushes whatever the name references to onto the stack, without evaluating them
\item sequences and functions; Towel pushes them onto the stack without executing it
\item backquotes; why would you do such a thing?
\end{itemize}

You can create backquoted shared sequence by replacing the parentheses with braces and dropping the at symbol. See also \autoref{ssec:backquote} and \autoref{ssec:macro}.

\section{\texttt{if} Forms}

Towel supports 10 kinds of \texttt{if} forms for the sake of readability and convenience. They are of the same form, while differing in the predicate they use.

An \texttt{if} form contains two words separated by a comma. When evaluating an \texttt{if} form, Towel tests the TOS and see if it satisfies the condition. If the condition is satisfied, the first word (called the true branch) is evaluated and the second word is ignored\footnote{This is basically why you want a designated condition form}, and vice versa. By default, \texttt{if} forms does not consume TOS, see \autoref{sec:switches} for more detail.

The predicates used by \texttt{if} forms are as follows:
\begin{itemize}
\item \texttt{if>0}, if TOS is a number and greater than 0
\item \texttt{if>=0}, if TOS is a number and greater than or equal to 0
\item \texttt{if<0}, if TOS is a number and less than 0
\item \texttt{if<=0}, if TOS is a number and less than or equal to 0
\item \texttt{if=0}, if TOS is a number and equal to 0
\item \texttt{if\textasciitilde 0}, if TOS is a number and not equal to 0
\item \texttt{ife}, if the stack is empty
\item \texttt{ifne}, if the stack is not empty
\item \texttt{ift}, if TOS is an atom and equal to \texttt{true}
\item \texttt{iff}, if TOS is an atom and equal to \texttt{false}
\end{itemize}

See \autoref{chap:examples} for examples on \texttt{if} forms.

\section{Function Form}

Function forms are used to define anonymous functions of arbitrary arity. To define a function, first type the keyword \texttt{fun}, and a list of argument declarations and finally a word for the body of the function.

Because function form creates and evaluates function in place, the following code is valid\footnote{But not semantically correct, because you cannot invoke a number as function.}:
\begin{mdframed}[style=example]
\begin{verbatim}
  fun A B,
    (A B fun X, (3 X +))
\end{verbatim}
\end{mdframed}
In practice, you may want to use the \texttt{bind-then} form and backquote jointly to create functions. You use backquote to prevent the function from evaluating so that you can use it later, for example, in the \texttt{then} clause.

\begin{mdframed}[style=example]
\begin{verbatim}
  bind Some-practical-function fun` ~arg1 ~arg2 ~arg3,
    (~~do-something-with-the-arguments~~)
  then (Some-arg1 Some-arg2 Some-arg3 Some-practical-function)
\end{verbatim}
\end{mdframed}

\begin{mdframed}[style=hint]
  You can also use the punctuation sequence ``\texttt{,\textbackslash}'' to replace \texttt{fun`}.
\end{mdframed}

See \autoref{chap:examples} for concrete examples.

\subsection{Tail Recursive Function Calls}

Any practical functional programming language provides tail recursion optimization. So does Towel. However, Towel is unable to identify\footnote{\textit{I admit I had been lazy.}} whether a function call is tail recursive, so users are responsible for tagging tail recursive calls with an at symbol at the end of the name of the function, like this:

\begin{mdframed}[style=example]
\begin{verbatim}
  bind Loop fun` F It End,
    (It End - if=0 (It F),
                (It F F` It 1 + End Loop@)
  then (("looping" !println)` 1 10 Loop).
\end{verbatim}
\end{mdframed}

\subsection{Currying}

When applied with insufficient number of arguments, Towel will return a partially applied function instead of doing all the computation it is supposed to. To be more precisely, Towel copies the function being called as a new value, install the arguments already applied to that new function value, then return this new function value as the return value of the old function. \sout{Yummy!}

\begin{mdframed}[style=example]
\begin{verbatim}
  bind ~dec-1 (1 -)
  then ('The Answer is ' !print 43 ~dec-1 !println)
\end{verbatim}
\end{mdframed}

\subsection{Phony}

A phony in Towel, is a special value on stack. When a phony is the current TOS, the stack will be considered empty. To push a phony onto the current stack, use \mstd{\$\$}.

\begin{mdframed}[style=example]
\begin{verbatim}
  ($$ ife (true !println), (false !println))
\end{verbatim}
  This will print \texttt{true}.
\end{mdframed}

Often, phony is used in conjunction with currying to create a curried function.

\begin{mdframed}[style=hint]
  Note that every phony will be popped by the TVM right after it is used, otherwise it will shadow anything pushed before it. For example the following code can produce expected answer because of this feature:

\begin{verbatim}
  ([1 2 3 4 5] $$ 3 < /filter !println)
\end{verbatim}

The output will be \texttt{[4 5]}.
\end{mdframed}

\section{Bind Form}

Use bind forms to add new name bindings in a new scope. Names can be bound to any kind of values such as functions, atoms, and all kinds of literals as long as they exist on the stack.

Simply type \texttt{bind} followed by the name and the value. Use keyword \texttt{also} to bind more names to more values. Bind forms have a compulsory \texttt{then} clause, which is followed by a word. You can do your computation under the name scope after this name binding in the \texttt{then} clause. Top-level name bindings, i.e. names bound by the outmost bind form, are visible across modules, you may want to take advantage of this behavior.

\begin{mdframed}[style=example]
\begin{verbatim}
  bind A 40
  also B 2
  then (A B + !println)
\end{verbatim}
\end{mdframed}

\begin{mdframed}[style=detail]
  Binding in TVM is currently implemented as names associating to the absolute index of the values in the stack. See also the following warning.
\end{mdframed}

\begin{mdframed}[style=warning]
Note that all the computations are done on stacks, so are bindings. That is to say that, the values that get bound exists on stacks. So you may want to be careful about this.

You may overflow your stack by using the \texttt{bind-then} form in a series of tail recursive calls if you forget to pop the values you bind previously.\footnote{Tail recursive calls in Towel don't offer you a whole new stack (or to say erase the stack for you), but rather continue to use the same stack the caller have been using.}

Fasten your seat belts for the next two examples.

\begin{verbatim}
  bind Answer 42
  then (!!pop Answer !println)
\end{verbatim}

will result in your program blowing up, because the position where there used to hold the value for the Answer is now invalid.

What's more scare is this,

\begin{verbatim}
  bind Answer 42
  then (!!pop 41 Answer !println)
\end{verbatim}

You just accidentally changed the value of the Answer without even noticing it!
\end{mdframed}

\section{Module}

Modules, or namespaces, in Towel, are sets of names. Mechanisms like this prevent names of various files from colliding into each other.

\subsection{Importing a Module}

To import a module, use the \texttt{import} form.
\begin{mdframed}[style=example]
\begin{verbatim}
  import 'std' \
  import 'std' @
\end{verbatim}
\end{mdframed}

The first \texttt{import} form means importing the module defined in a file named \texttt{'std.w'}, and name that module \texttt{Std} so that you can reference to the names from this module as \mstd{SomeName}. The ending punctuation backslash is exactly the samething you use for module referencing. This is called explicit importing.

The second \texttt{import} form ending with an at symbol, means not only importing the module \texttt{Std}, but also importing all the exported names in that module. In this way, you are allowed to reference to the names without having to specify the modules they are in. This is call implicit importing.

\begin{mdframed}[style=detail]
  During compilation, the file the compiler searches is a \texttt{'.e'} file, this file contains only all the names available in the respective module.

  During execution, however, the file the virtual machine needs is a \texttt{'.w'} file which is the compiled version of the actual program.

  Also note that in current version of TVM, implicit importing imports and pushes all the exported values from the imported module onto the stack. So you may expect a non-empty stack after implicit importing.
\end{mdframed}

\begin{mdframed}[style=detail]
  Be aware that imports affects exactly the current scope, and the children scopes of the current one. When current scope exits, the side-effect the import form brought about is also gone.

  This also implies that values pushed by implicit importing are popped along with the stack being destroyed.
\end{mdframed}

\begin{mdframed}[style=hint]
  For your imformation, no modules imported by default. You have to explicitly import any modules you want to use.
\end{mdframed}

The path of the module file \texttt{'std.w'}, is searched as the following order:
\begin{itemize}
\item the current working directory
\item the predefined directory \texttt{towelibs}
\end{itemize}

\begin{mdframed}[style=detail]
  In current implementation, you can modify both the \texttt{'compiler/config.ml'} and \texttt{'vm/config.ml'} and recompile them to change the default search paths. We may add a environment variable for search paths in the future.
\end{mdframed}

Note that you can import multiple modules in a single \texttt{import} statement.

\subsection{Exporting Names}

You can also export names in your module so that they are visible to other modules with \texttt{export} form as follows:

\begin{mdframed}[style=example]
\begin{verbatim}
  bind A 1
  also B 2
  also C 3
  then export A B C @.
\end{verbatim}
\end{mdframed}

The Towel compiler will automatically generate a \texttt{'.e'} file for each compiled \texttt{'.t'} file for the purposes of name exportation.\footnote{Very much like the C header files, but less powerful.} An empty one will be generated, even if there are no names exported in the source file.

\section{Wait, What about Garbage Collection?}

Towel definitely collects garbage for you!

In current implementation of the TVM, when a value is popped out from a stack, the value gets GC'ed immediately.\footnote{Mayn thanks to OCaml!} When a stack is popped from the data stack stack, all the values on the popped stack are GC'ed immediately. So basically, Towel gets garbage collection for free because of its stack-based computation model.

\section{Switches}
\label{sec:switches}

Towel provides some switches to change the default behavior of the compiler:
\begin{itemize}
\item \texttt{hungry}
\item \texttt{share-stack}
\item \texttt{optimize-seq}, on by default
\end{itemize}

If you want to turn on/off these switches, type in the switch names on first line, leave an empty line next to it, then go on with your code, like this:
\begin{verbatim}
  I'm so hungry! Also please share-stack.

  bind Something-new (1 2 -)
  then Something-new.
\end{verbatim}

If \texttt{hungry} is turned on, \texttt{if} forms will compile to the hungry version of their counterparts, which consume the TOS they test against when the test finishes, i.e. immediately after falling in particular branches or after failing to fall in any of the branches. This is useful when you want to be thrifty about stack spaces.

\begin{mdframed}[style=hint]
  You can also achieve this with \texttt{hungry} turned off by calling \mstd{!!pop} explicitly.
\end{mdframed}

When \texttt{share-stack} is on, every function (including sequence of course) uses the same stack, you get more classic stack-based language programming experience\footnote{And probably faster execution, because the context switching is done a lot faster without data stacks pushing and popping.} out of this switch, but you may want to make sure functions don't leave extra elements on the stack, so you'd better turn on \texttt{hungry} switch along with this.

If you turn on \texttt{optimize-seq} switch, when you create a sequence as the body of a function, \texttt{if} form, or \texttt{then} clause of \texttt{bind-then} forms, this sequence is optimized to disappear, leaving the body of it as the body of the form.

\chapter{The Standard Library}

\section{Naming Conventions}

In towel, we encourage Lisp-like naming styles. But since only upper-cased characters are allowed to appear as the first alphabet character in a name, we normally prepend a punctuation to it.

\begin{itemize}
\item For routines, we would normally prepend an exclamation mark to
  such routines. For example, \mstd{!print}. For routines with serious side-effects, we prepend two.

\item For functions that operate on enumerables, we prepend \texttt{\#}.

\item For functional functions, we prepend a slash (half of the $\lambda$ character). For example, we have in the standard library \mstd{/foldl}, \mstd{/map}.

\item For predicates (something that returns \texttt{true} or \texttt{false}), we prepend a question mark.

\item For arithmetic functions, we don't prepend anything.

\item For arguments, we usually prepend a \texttt{\mtilde} for the sake of simplicity.
\end{itemize}

\section{Module \texttt{Std}}

Module \texttt{Std} is the very basic standard library of the Towel programming language. It consists of functions of multiple domains.

\subsection{Arithmetic Functions}

This category contains the following functions:
\begin{itemize}
\item \arithstd{+}

add \marg1 and \marg2
\item \arithstd{-}

\marg1 minus \marg2
\item \arithstd{*}

multiply \marg1 and \marg2
\item \arithstd{/}

divide \marg1 by \marg2
\item \arithstd{**}

\marg1 to the power of \marg2
\item \arithstd{\%}

\marg1 modulo \marg2
\end{itemize}

\begin{mdframed}[style=hint]
  This leftarrow thing is just to highlight the arguments that should be applied to the function, and implies the stack-based nature of Towel, i.e. the order the functions acquire their arguments.

  For example, \arithstd{-} means that \mstd{-} grabs \marg2 first, then \marg1, but still calculates $\marg1 - \marg2$.
\end{mdframed}

It also contains various functions for comparison purposes:

\begin{itemize}
\item \arithstd{=}

tests if \marg1 equals to \marg2
\item \arithstd{>}

tests if \marg1 is the greater than \marg2
\item \arithstd{>=}

tests if \marg1 is the greater than \marg2
\item \arithstd{<}

tests if \marg1 is the less than \marg2
\item \arithstd{<=}

tests if \marg1 is the less than or equal to \marg2
\item \arithstd{<>}

tests if \marg1 is not equal to \marg2
\end{itemize}

Let's not forget about bitwise arithmetic functions:

\begin{itemize}
\item \arithstd{:and}

bitwise and between \marg1 and \marg2
\item \arithstd{:or}

bitwise or between \marg1 and \marg2
\item \arithstd{:not}

bitwise not \marg1
\item \arithstd{:xor}

bitwise xor between \marg1 and \marg2
\item \arithstd{:shl}

bitwise shift left \marg1 for \marg2 bits
\item \arithstd{:shr}

bitwise shift right \marg1 for \marg2 bits
\item \arithstd{:lshr}

bitwise logical shift right \marg1 for \marg2 bits
\end{itemize}

\begin{mdframed}[style=hint]
  Arithmetic functions only work for numbers.

  The equality and non-equality function works for most of the types (including type \texttt{Type}).
  The comparison functions only work for numbers because they are implemented using the substraction function.

  Bitwise functions only work for fixed integer and unsigned fixed integer.
\end{mdframed}

\begin{mdframed}[style=hint]
  The above functions must be applied to values of the same type. Otherwise the TVM will throw an error and exit.
\end{mdframed}

\subsection{Conversion Functions}

Because Towel is a strong-typed language, we provide you some conversion functions to cast the values around.

\begin{mdframed}[style=warning]
  Think before you use these functions.
\end{mdframed}

\begin{itemize}
\item \marg1 \mla \mstd{\textasciitilde fint}

converts \marg1 of unsigned fixed integers, floats, big integers, or strings into a fixed integer
\item \marg1 \mla \mstd{\textasciitilde ufint}

converts \marg1 of unsigned fixed integers, floats, big integers, or strings into an unsigned fixed integer
\item \marg1 \mla \mstd{\textasciitilde int}

converts \marg1 of unsigned fixed integers, floats, big integers, or strings into a big integer
\item \marg1 \mla \mstd{\textasciitilde float}

converts \marg1 of unsigned fixed integers, floats, big integers, or strings into float number
\item \marg1 \mla \mstd{\textasciitilde str}

stringifies \marg1 of any possible value to a string
\end{itemize}

\subsection{Reflection Function}

Use \texttt{\string^?} if you want to know the type of a value at runtime. The return value of this function can be tested equality against other type values.

\subsection{Routines}

\begin{itemize}
\item \marg{x} \mla \mstd{!print}

prints \marg{x}
\item \marg{x} \mla \mstd{!println}

prints \marg{x} plus a newline character
\item \mstd{!read}

reads in a string from standard input and push it onto the stack
\item \mstd{!!pop}

pop the last element on current stack
\item \mstd{!!dup}

duplicate the last element on current stack
\item \texttt{...} \mla \marg{n} \mla \mstd{!!pack}

pack \marg{n} elements on current stack into a list
\item \marg1 \mla \mstd{!!unpack}

unpack \marg1 into N elements and push them onto current stack
\end{itemize}

\begin{mdframed}[style=hint]
  Because of the low-levelness of \mstd{!!pack} and \mstd{!!unpack}, they do not accept argument the same way other functions do, but directly from current stack. So you cannot create curried functions out of them.
\end{mdframed}

\subsection{Phony}

Use \mstd{\$\$} to push a phony onto current stack.

\begin{mdframed}[style=warning]
  Do not try to \mstd{!!pop} a phony, it will result in an \texttt{PhonyEmptyStack} error.
\end{mdframed}

\subsection{Working with Enumerables}


\subsubsection{Functions that Works with Both Lists and Tuples}

Only one exists for now: \marg{x} \mla \mstd{?\#}, \marg{x} emptiness test.

\subsubsection{List-only Functions}

\begin{itemize}
\item \marg{l} \mla \mstd{\#hd}

get the head of \marg{l}
\item \marg{l} \mla \mstd{\#tl}

get the tail of \marg{l}
\item \marg{e} \mla \marg{l} \mla \mstd{\#cons}

cons \marg{e} and \marg{l} into a new list
\item \marg{l} \mla \mstd{\#rev}

reverse \marg{l}
\item \marg{l1} \mla \marg{l2} \mla \mstd{\#concat}

concatenate \marg{l1} and \marg{l2}
\item \marg{l} \mla \mstd{\#len}

get the length of \marg{l}
\end{itemize}

\begin{mdframed}[style=hint]
  Remember everything in Towel is immutable.
\end{mdframed}

\subsubsection{Tuple-only Functions}

\begin{itemize}
\item \marg{n} \mla \marg{t} \mla \mstd{\#tn}

get the \marg{n}-th element of \marg{t}
\item \marg{t} \mla \mstd{\#t1}

get the first element of \marg{t}
\item \marg{t} \mla \mstd{\#t2}

get the second element of \marg{t}
\item \marg{t} \mla \mstd{\#t3}

get the third element of \marg{t}
\end{itemize}

\subsection{Functional Functions}

\begin{itemize}
\item \marg{x} \mla \mstd{/id}

the identity function, i.e. it returns \marg{x}
\item \marg{init} \mla \marg{list} \mla \marg{fun} \mla \mstd{/foldl}

folds the  list\marg{list} from left to right on function \marg{fun}, with the initial value being \marg{init}.
\item \marg{init} \mla \marg{list} \mla \marg{fun} \mla \mstd{/foldr}

same as \mstd{/foldl}, except that this walks the list from right to left and is not tail recursive function.
\item \marg{list} \mla \marg{fun} \mla \mstd{/map}

maps function denoted by \marg{fun} onto \marg{list}.
\item \marg{list} \mla \texttt{?pred} \mla \mstd{/filter}

for each element \marg{x} in \marg{list}, discards \marg{x} when \texttt{\marg{x} ?pred} turns out to be \texttt{true}.
\item \marg1 \mla \marg2 \mla \marg{fun} \mla \mstd{/flip}

flips the arguments of a binary function \marg{fun}, i.e. \texttt{\marg2 \marg1 \marg{fun}}.
\item \marg{args} \mla \marg{fun} \mla \mstd{/apply}

apply the elements in \marg{args} as arguments to \marg{fun}.
\end{itemize}

\begin{mdframed}[style=hint]
  You may want to use backquotes when using these functions, for example,

\begin{verbatim}
  ([1 2 3 4 5] !println /map)
\end{verbatim}

prints out
\begin{verbatim}
  [1 2 3 4 5]
\end{verbatim}

rather than
\begin{verbatim}
  1
  2
  3
  4
  5
\end{verbatim}

To do this correctly, you should backquote \texttt{!println} like this

\begin{verbatim}
  ([1 2 3 4 5] !println` /map)
\end{verbatim}

This backquote prevents \texttt{!println} from executing, leaving it be as a function value so that it can be passed to \texttt{/map}.
\end{mdframed}

\section{Module \texttt{Random}}

This module exploits the extension mechanism provided by current implementation of the TVM to easily invoke functions in OCaml. See the virtual machine manual for more details.

The provided functions are
\begin{itemize}
\item \marg{s} \mla \texttt{\mtilde ~seed\textbackslash Random}

change the seed used in random number generation to \marg{s}
\item \texttt{\mtilde ~useed\textbackslash Random}

change the seed according to \texttt{/dev/urandom} on *nix systems, or system parameters if \texttt{/dev/urandom} is not available
\item \texttt{\mtilde ~\mtilde ~\textbackslash Random}

generates a random floating point number within the range of $[0.0, 1.0]$.
\end{itemize}


\chapter{The Towel Compiler \texttt{weave} Howto}

To compile a source file \texttt{foo.t}, and want the compiled output to be \texttt{bar.w}, use
\begin{verbatim}
        path-to-weave foo.t -o bar.w
\end{verbatim}

If you want to see the human-readable bytecode file, apply -t to \texttt{weave}, for example
\begin{verbatim}
        path-to-weave foo.t -o bar.l -t
\end{verbatim}

If you want to read the unassembled compiled file (human-readable) for debugging purposes, apply -r to \texttt{weave} like this
\begin{verbatim}
        path-to-weave foo.t -o bar.o -r
\end{verbatim}

If you have a human-readable bytecode file, and want to compile into VM-readable bytecode file, apply -b to \texttt{weave}, e.g.
\begin{verbatim}
        path-to-weave foo.l -o bar.w -b
\end{verbatim}

\begin{mdframed}[style=hint]
  Recommended extension for Towel source file is \texttt{.t}, because it's the first letter of the word \textit{towel}.

  Recommended extension for raw unassembled compiled file is \texttt{.o}, which means original Towel.

  Recommended extension for Towel bytecode file is \texttt{.w}, meaning woven Towel. It's also the third letter of \textit{towel}!\footnote{I love wordplay so much!}.

  By default, files that contains the exported names of the module have the extension of \texttt{.e}, meaning exportation.

  And finally recommended extension for human-readable bytecode file is \texttt{.l}.
\end{mdframed}

\chapter{Examples}
\label{chap:examples}

The following examples runs under the default compiler switch configuration.

\section{Concrete Examples}

\subsection{Greatest Common Divisor}
\begin{mdframed}[style=example]
\begin{verbatim}
  import 'std' @

  bind GCD fun` A B,
    (A B - if=0 A (5),
       if>0 (1) (!!pop A B - B GCD@ (2)),
       if<0 (!!pop (3) A B A - GCD@),
         ~idle (4))
  then (42 24 GCD !println)
\end{verbatim}
\end{mdframed}

\begin{enumerate}
\item See how \texttt{if} forms are chained here!
\item Note that we are tail recursing the \texttt{GCD} function here.
\item As is mentioned in previous chapters, when doing tail recursive calls, you really want to be careful about your stack usage to avoid stack leakage.
\item Remember an \texttt{if} form have two branches, and both of them cannot be omitted. So we put \sout{Eric Idle} \mstd{\mtilde ~idle} here to denote that we don't want to do anything here.
\item The exit of the recursive function, so we'll directly put \texttt{A} here, without popping the result of \texttt{A B -}. Because this stack will be destroyed and all the values on it GC'ed, after it returns \texttt{A}.
\end{enumerate}

\subsection{Fibonacci Numbers}
\begin{mdframed}[style=example]
\begin{verbatim}
  bind Fib fun` A B N,
    if=0 A, (A B + A 1 N - Fib@)
  then (1 1 10 Fib).
\end{verbatim}
\end{mdframed}
Trivial.

\section{Advanced Examples}

\subsection{Quicksort}
\begin{mdframed}[style=example]
\begin{verbatim}
  import 'std' @ (1)

  bind #quicksort (2) ,\ (3) L,
    (L ?#empty ift (!!pop (4) []), (!!pop
      bind ~h (L #hd)
      also ~t (L #tl)
      then (~t (~h >) (5) /filter #quicksort
            [~h]
            ~t (~h <=) /filter #quicksort
        #concat #concat (6))))
  then ([5 4 3 2 1] #quicksort !println)
\end{verbatim}
\end{mdframed}

\begin{enumerate}
\item Implicitly import module \texttt{Std} so that we can use the names bound in it without referencing to the module name.
\item Remember our naming conventions? Quicksort works on lists, so we prepend a \texttt{\#} to it.
\item It's a synonym for \texttt{fun`}.
\item Use \mstd{!!pop} to be thrifty about memory spaces.
\item Utilizing non-shared sequence to create partial applied function.
\item We have three lists on stack, so it takes two \mstd{\#concat}s to merge them all into one list.
\end{enumerate}

\subsection{Backquotes}
\label{ssec:backquote}
\begin{verbatim}
  bind SomeFun fun A,
    if~0 +`, -`
  then bind AnotherFun fun A B,
    (A B A SomeFun)
  then (1 5 AnotherFun).
\end{verbatim}

A quick explanation: when \texttt{SomeFun} is called with \texttt{A}, it returns either evaluated backquoted name \texttt{+} or \texttt{-}, in other words, it returns either name \texttt{+} or \texttt{-}.

What the \textbf{returning} actually does is that it cleans up the current function, and pushes whatever is on top of the stack (a name \texttt{+} or \texttt{-} in this case) of the current function (in this case, it is the stack of \texttt{SomeFun}) onto the caller's stack (in this case, it is the stack of \texttt{AnotherFun}). And finally jump to the instruction next to the last one. So there is a name \texttt{+} or \texttt{-} on top of the function \texttt{AnotherFun}.

And because we are evaluating return values of functions, \texttt{+} and \texttt{-} are evaluated (derefenced to) some function values, for example \texttt{fv1:0x0001} and \texttt{fv2:0x0002}. And again because we are evaluating values that the names are pointing to, one of \texttt{fv1:0x0001} and \texttt{fv2:0x0002} is called\footnote{It is worth mentioning that because we have exited \texttt{SomeFun}, we are now evaluating the function value with the stack of \texttt{AnotherFun}} with \texttt{A} and \texttt{B}, thus resulting in either adding or substracting \texttt{A} and \texttt{B}.

\subsection{Macro}
\label{ssec:macro}
\begin{verbatim}
  bind A-Macro fun,
    (@ if~0 +, -)`
  also B-Macro fun,
    {if~0 +, -}
  then bind AnotherFun fun A B,
    (A B A-Macro)
  then (1 2 AnotherFun).
\end{verbatim}

A quick explanation: \texttt{(@ if\textasciitilde 0 +, -)} is returned as we want, so a sequence (which is essentially an anonymous function that test whether the value on top of the stack is zero), and by adding a \texttt{@} we define the sequence to be a shared sequence which shares the same stack with the caller, so the overall effect is like we have done a code replacement.

\texttt{B-Macro} is a short-hand version of \texttt{A-Macro}.

You can define \texttt{++3} we talked about before as follows:
\begin{verbatim}
  bind ++3 fun, {++ ++}
  then ([1 2 3] [2 3 4] [3 4 5] ++3).
\end{verbatim}

\subsection{Algebraic Data Type}
\label{ssec:adt-example}
\begin{verbatim}
  type BinTree [@ {a}BinTree {a}BinTree] tree,
               [@ a] leaf
  also MyList [@ a {a}MyList] cons,
              nil
  then bind A [@ [@ [@ 42 nil\MyList] cons\MyList] leaf\BinTree
                 [@ [@ 42 nil\MyList] cons\MyList] leaf\BinTree]
              tree\BinTree
  then Idle.

  export A.
\end{verbatim}

This is equivalent to the following OCaml code:
\begin{verbatim}
  type 'a bin_tree = Tree of a bin_tree * a bin_tree
                   | Leaf of a;;
  type 'a my_list = Cons of a * a my_list
                  | Nil;;
  let a = Tree(Leaf(Cons(42, Nil)), Leaf(Cons(42, Nil)))
\end{verbatim}

\end{document}
